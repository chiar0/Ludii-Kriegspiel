//------------------------------------------------------------------------------
// Project Title: Refactoring Kriegspiel for a Constrained and AI-Ready User Interface
// Objective: Modify the game for a geometrically constrained user interface,
// while maintaining the imperfect information arbitration logic.
// Modification Author: Fabio Chiarini (f.chiarini1@studenti.unipi.it)
//------------------------------------------------------------------------------

// Definition: NextCanNotMove
// Checks if the 'next' player (the opponent) has any legal moves available.
// Used to detect stalemate or checkmate conditions.
(define "NextCanNotMove"
    (not
        (can Move
            (do
                (forEach Piece Next) // Iterate through all pieces of the next player
                // After performing a potential move, check if the King of the next player is in check.
                // A move is considered legal only if it doesn't leave the King in check.
                ifAfterwards:(not ("KingInCheck" (next)(mover)))
            )
        )
    )
)

// Definition: HasNeverMoved
// Checks if a specific piece (King or Rook for castling) has ever moved from its starting position.
// The initial state for these pieces is 1, and it's set to 0 after their first move.
(define "HasNeverMoved"
    (= (state at:(mapEntry #1 (mover))) 1)
)

// Definition: PieceHasMoved
// Sets the state of a piece to 0, indicating it has moved.
// Used for tracking castling eligibility.
(define "PieceHasMoved"
    (set State at:#1 0)
)

// Definition: NoteCapture
// Umpire announcement for piece captures.
// This macro identifies the captured piece's location (#1) and type (#2)
// (Pawn: <=2, Piece: >2) and issues a note for the player.
// The extensive coordinate checks are for specific messaging per square.
(define "NoteCapture"
    (and {
        (if (and (= (#1)(coord:"A1")) (<= (#2) 2)) (note "Pawn at A1 captured"))
        (if (and (= (#1)(coord:"A1")) (> (#2) 2)) (note "Piece at A1 captured"))
        (if (and (= (#1)(coord:"A2")) (<= (#2) 2)) (note "Pawn at A2 captured"))
        (if (and (= (#1)(coord:"A2")) (> (#2) 2)) (note "Piece at A2 captured"))
        (if (and (= (#1)(coord:"A3")) (<= (#2) 2)) (note "Pawn at A3 captured"))
        (if (and (= (#1)(coord:"A3")) (> (#2) 2)) (note "Piece at A3 captured"))
        (if (and (= (#1)(coord:"A4")) (<= (#2) 2)) (note "Pawn at A4 captured"))
        (if (and (= (#1)(coord:"A4")) (> (#2) 2)) (note "Piece at A4 captured"))
        (if (and (= (#1)(coord:"A5")) (<= (#2) 2)) (note "Pawn at A5 captured"))
        (if (and (= (#1)(coord:"A5")) (> (#2) 2)) (note "Piece at A5 captured"))
        (if (and (= (#1)(coord:"A6")) (<= (#2) 2)) (note "Pawn at A6 captured"))
        (if (and (= (#1)(coord:"A6")) (> (#2) 2)) (note "Piece at A6 captured"))
        (if (and (= (#1)(coord:"A7")) (<= (#2) 2)) (note "Pawn at A7 captured"))
        (if (and (= (#1)(coord:"A7")) (> (#2) 2)) (note "Piece at A7 captured"))
        (if (and (= (#1)(coord:"A8")) (<= (#2) 2)) (note "Pawn at A8 captured"))
        (if (and (= (#1)(coord:"A8")) (> (#2) 2)) (note "Piece at A8 captured"))
        (if (and (= (#1)(coord:"B1")) (<= (#2) 2)) (note "Pawn at B1 captured"))
        (if (and (= (#1)(coord:"B1")) (> (#2) 2)) (note "Piece at B1 captured"))
        (if (and (= (#1)(coord:"B2")) (<= (#2) 2)) (note "Pawn at B2 captured"))
        (if (and (= (#1)(coord:"B2")) (> (#2) 2)) (note "Piece at B2 captured"))
        (if (and (= (#1)(coord:"B3")) (<= (#2) 2)) (note "Pawn at B3 captured"))
        (if (and (= (#1)(coord:"B3")) (> (#2) 2)) (note "Piece at B3 captured"))
        (if (and (= (#1)(coord:"B4")) (<= (#2) 2)) (note "Pawn at B4 captured"))
        (if (and (= (#1)(coord:"B4")) (> (#2) 2)) (note "Piece at B4 captured"))
        (if (and (= (#1)(coord:"B5")) (<= (#2) 2)) (note "Pawn at B5 captured"))
        (if (and (= (#1)(coord:"B5")) (> (#2) 2)) (note "Piece at B5 captured"))
        (if (and (= (#1)(coord:"B6")) (<= (#2) 2)) (note "Pawn at B6 captured"))
        (if (and (= (#1)(coord:"B6")) (> (#2) 2)) (note "Piece at B6 captured"))
        (if (and (= (#1)(coord:"B7")) (<= (#2) 2)) (note "Pawn at B7 captured"))
        (if (and (= (#1)(coord:"B7")) (> (#2) 2)) (note "Piece at B7 captured"))
        (if (and (= (#1)(coord:"B8")) (<= (#2) 2)) (note "Pawn at B8 captured"))
        (if (and (= (#1)(coord:"B8")) (> (#2) 2)) (note "Piece at B8 captured"))
        (if (and (= (#1)(coord:"C1")) (<= (#2) 2)) (note "Pawn at C1 captured"))
        (if (and (= (#1)(coord:"C1")) (> (#2) 2)) (note "Piece at C1 captured"))
        (if (and (= (#1)(coord:"C2")) (<= (#2) 2)) (note "Pawn at C2 captured"))
        (if (and (= (#1)(coord:"C2")) (> (#2) 2)) (note "Piece at C2 captured"))
        (if (and (= (#1)(coord:"C3")) (<= (#2) 2)) (note "Pawn at C3 captured"))
        (if (and (= (#1)(coord:"C3")) (> (#2) 2)) (note "Piece at C3 captured"))
        (if (and (= (#1)(coord:"C4")) (<= (#2) 2)) (note "Pawn at C4 captured"))
        (if (and (= (#1)(coord:"C4")) (> (#2) 2)) (note "Piece at C4 captured"))
        (if (and (= (#1)(coord:"C5")) (<= (#2) 2)) (note "Pawn at C5 captured"))
        (if (and (= (#1)(coord:"C5")) (> (#2) 2)) (note "Piece at C5 captured"))
        (if (and (= (#1)(coord:"C6")) (<= (#2) 2)) (note "Pawn at C6 captured"))
        (if (and (= (#1)(coord:"C6")) (> (#2) 2)) (note "Piece at C6 captured"))
        (if (and (= (#1)(coord:"C7")) (<= (#2) 2)) (note "Pawn at C7 captured"))
        (if (and (= (#1)(coord:"C7")) (> (#2) 2)) (note "Piece at C7 captured"))
        (if (and (= (#1)(coord:"C8")) (<= (#2) 2)) (note "Pawn at C8 captured"))
        (if (and (= (#1)(coord:"C8")) (> (#2) 2)) (note "Piece at C8 captured"))
        (if (and (= (#1)(coord:"D1")) (<= (#2) 2)) (note "Pawn at D1 captured"))
        (if (and (= (#1)(coord:"D1")) (> (#2) 2)) (note "Piece at D1 captured"))
        (if (and (= (#1)(coord:"D2")) (<= (#2) 2)) (note "Pawn at D2 captured"))
        (if (and (= (#1)(coord:"D2")) (> (#2) 2)) (note "Piece at D2 captured"))
        (if (and (= (#1)(coord:"D3")) (<= (#2) 2)) (note "Pawn at D3 captured"))
        (if (and (= (#1)(coord:"D3")) (> (#2) 2)) (note "Piece at D3 captured"))
        (if (and (= (#1)(coord:"D4")) (<= (#2) 2)) (note "Pawn at D4 captured"))
        (if (and (= (#1)(coord:"D4")) (> (#2) 2)) (note "Piece at D4 captured"))
        (if (and (= (#1)(coord:"D5")) (<= (#2) 2)) (note "Pawn at D5 captured"))
        (if (and (= (#1)(coord:"D5")) (> (#2) 2)) (note "Piece at D5 captured"))
        (if (and (= (#1)(coord:"D6")) (<= (#2) 2)) (note "Pawn at D6 captured"))
        (if (and (= (#1)(coord:"D6")) (> (#2) 2)) (note "Piece at D6 captured"))
        (if (and (= (#1)(coord:"D7")) (<= (#2) 2)) (note "Pawn at D7 captured"))
        (if (and (= (#1)(coord:"D7")) (> (#2) 2)) (note "Piece at D7 captured"))
        (if (and (= (#1)(coord:"D8")) (<= (#2) 2)) (note "Pawn at D8 captured"))
        (if (and (= (#1)(coord:"D8")) (> (#2) 2)) (note "Piece at D8 captured"))
        (if (and (= (#1)(coord:"E1")) (<= (#2) 2)) (note "Pawn at E1 captured"))
        (if (and (= (#1)(coord:"E1")) (> (#2) 2)) (note "Piece at E1 captured"))
        (if (and (= (#1)(coord:"E2")) (<= (#2) 2)) (note "Pawn at E2 captured"))
        (if (and (= (#1)(coord:"E2")) (> (#2) 2)) (note "Piece at E2 captured"))
        (if (and (= (#1)(coord:"E3")) (<= (#2) 2)) (note "Pawn at E3 captured"))
        (if (and (= (#1)(coord:"E3")) (> (#2) 2)) (note "Piece at E3 captured"))
        (if (and (= (#1)(coord:"E4")) (<= (#2) 2)) (note "Pawn at E4 captured"))
        (if (and (= (#1)(coord:"E4")) (> (#2) 2)) (note "Piece at E4 captured"))
        (if (and (= (#1)(coord:"E5")) (<= (#2) 2)) (note "Pawn at E5 captured"))
        (if (and (= (#1)(coord:"E5")) (> (#2) 2)) (note "Piece at E5 captured"))
        (if (and (= (#1)(coord:"E6")) (<= (#2) 2)) (note "Pawn at E6 captured"))
        (if (and (= (#1)(coord:"E6")) (> (#2) 2)) (note "Piece at E6 captured"))
        (if (and (= (#1)(coord:"E7")) (<= (#2) 2)) (note "Pawn at E7 captured"))
        (if (and (= (#1)(coord:"E7")) (> (#2) 2)) (note "Piece at E7 captured"))
        (if (and (= (#1)(coord:"E8")) (<= (#2) 2)) (note "Pawn at E8 captured"))
        (if (and (= (#1)(coord:"E8")) (> (#2) 2)) (note "Piece at E8 captured"))
        (if (and (= (#1)(coord:"F1")) (<= (#2) 2)) (note "Pawn at F1 captured"))
        (if (and (= (#1)(coord:"F1")) (> (#2) 2)) (note "Piece at F1 captured"))
        (if (and (= (#1)(coord:"F2")) (<= (#2) 2)) (note "Pawn at F2 captured"))
        (if (and (= (#1)(coord:"F2")) (> (#2) 2)) (note "Piece at F2 captured"))
        (if (and (= (#1)(coord:"F3")) (<= (#2) 2)) (note "Pawn at F3 captured"))
        (if (and (= (#1)(coord:"F3")) (> (#2) 2)) (note "Piece at F3 captured"))
        (if (and (= (#1)(coord:"F4")) (<= (#2) 2)) (note "Pawn at F4 captured"))
        (if (and (= (#1)(coord:"F4")) (> (#2) 2)) (note "Piece at F4 captured"))
        (if (and (= (#1)(coord:"F5")) (<= (#2) 2)) (note "Pawn at F5 captured"))
        (if (and (= (#1)(coord:"F5")) (> (#2) 2)) (note "Piece at F5 captured"))
        (if (and (= (#1)(coord:"F6")) (<= (#2) 2)) (note "Pawn at F6 captured"))
        (if (and (= (#1)(coord:"F6")) (> (#2) 2)) (note "Piece at F6 captured"))
        (if (and (= (#1)(coord:"F7")) (<= (#2) 2)) (note "Pawn at F7 captured"))
        (if (and (= (#1)(coord:"F7")) (> (#2) 2)) (note "Piece at F7 captured"))
        (if (and (= (#1)(coord:"F8")) (<= (#2) 2)) (note "Pawn at F8 captured"))
        (if (and (= (#1)(coord:"F8")) (> (#2) 2)) (note "Piece at F8 captured"))
        (if (and (= (#1)(coord:"G1")) (<= (#2) 2)) (note "Pawn at G1 captured"))
        (if (and (= (#1)(coord:"G1")) (> (#2) 2)) (note "Piece at G1 captured"))
        (if (and (= (#1)(coord:"G2")) (<= (#2) 2)) (note "Pawn at G2 captured"))
        (if (and (= (#1)(coord:"G2")) (> (#2) 2)) (note "Piece at G2 captured"))
        (if (and (= (#1)(coord:"G3")) (<= (#2) 2)) (note "Pawn at G3 captured"))
        (if (and (= (#1)(coord:"G3")) (> (#2) 2)) (note "Piece at G3 captured"))
        (if (and (= (#1)(coord:"G4")) (<= (#2) 2)) (note "Pawn at G4 captured"))
        (if (and (= (#1)(coord:"G4")) (> (#2) 2)) (note "Piece at G4 captured"))
        (if (and (= (#1)(coord:"G5")) (<= (#2) 2)) (note "Pawn at G5 captured"))
        (if (and (= (#1)(coord:"G5")) (> (#2) 2)) (note "Piece at G5 captured"))
        (if (and (= (#1)(coord:"G6")) (<= (#2) 2)) (note "Pawn at G6 captured"))
        (if (and (= (#1)(coord:"G6")) (> (#2) 2)) (note "Piece at G6 captured"))
        (if (and (= (#1)(coord:"G7")) (<= (#2) 2)) (note "Pawn at G7 captured"))
        (if (and (= (#1)(coord:"G7")) (> (#2) 2)) (note "Piece at G7 captured"))
        (if (and (= (#1)(coord:"G8")) (<= (#2) 2)) (note "Pawn at G8 captured"))
        (if (and (= (#1)(coord:"G8")) (> (#2) 2)) (note "Piece at G8 captured"))
        (if (and (= (#1)(coord:"H1")) (<= (#2) 2)) (note "Pawn at H1 captured"))
        (if (and (= (#1)(coord:"H1")) (> (#2) 2)) (note "Piece at H1 captured"))
        (if (and (= (#1)(coord:"H2")) (<= (#2) 2)) (note "Pawn at H2 captured"))
        (if (and (= (#1)(coord:"H2")) (> (#2) 2)) (note "Piece at H2 captured"))
        (if (and (= (#1)(coord:"H3")) (<= (#2) 2)) (note "Pawn at H3 captured"))
        (if (and (= (#1)(coord:"H3")) (> (#2) 2)) (note "Piece at H3 captured"))
        (if (and (= (#1)(coord:"H4")) (<= (#2) 2)) (note "Pawn at H4 captured"))
        (if (and (= (#1)(coord:"H4")) (> (#2) 2)) (note "Piece at H4 captured"))
        (if (and (= (#1)(coord:"H5")) (<= (#2) 2)) (note "Pawn at H5 captured"))
        (if (and (= (#1)(coord:"H5")) (> (#2) 2)) (note "Piece at H5 captured"))
        (if (and (= (#1)(coord:"H6")) (<= (#2) 2)) (note "Pawn at H6 captured"))
        (if (and (= (#1)(coord:"H6")) (> (#2) 2)) (note "Piece at H6 captured"))
        (if (and (= (#1)(coord:"H7")) (<= (#2) 2)) (note "Pawn at H7 captured"))
        (if (and (= (#1)(coord:"H7")) (> (#2) 2)) (note "Piece at H7 captured"))
        (if (and (= (#1)(coord:"H8")) (<= (#2) 2)) (note "Pawn at H8 captured"))
        (if (and (= (#1)(coord:"H8")) (> (#2) 2)) (note "Piece at H8 captured"))
    })
)

// Definition: KingGravitatesToMainDiagonal
// Checks if the King of the 'Next' player is currently in one of the two main diagonal quadrants.
// Used for specific 'diagonal check' announcements in Kriegspiel.
(define "KingGravitatesToMainDiagonal"
    (or
        (and (< (row of:(where "King" Next)) 4) (< (column of:(where "King" Next)) 4))
        (and (>= (row of:(where "King" Next)) 4) (>= (column of:(where "King" Next)) 4))
    )
)

// Definition: KingGravitatesToAntiDiagonal
// Checks if the King of the 'Next' player is currently in one of the two anti-diagonal quadrants.
// Used for specific 'diagonal check' announcements in Kriegspiel.
(define "KingGravitatesToAntiDiagonal"
    (or
        (and (< (row of:(where "King" Next)) 4) (>= (column of:(where "King" Next)) 4))
        (and (>= (row of:(where "King" Next)) 4) (< (column of:(where "King" Next)) 4))
    )
)

// Definition: PawnDiagonalCheck
// Checks if a Pawn of the 'mover' player is diagonally attacking the King of player #1
// in direction #3. This is specific for pawns attacking diagonally.
(define "PawnDiagonalCheck"
    (= (what at: (ahead (where "King" #1) steps:1 #3)) (mapEntry "Pawn" #2))
)

// Definition: DiagonalCheck
// Checks if a Queen or Bishop of the 'mover' player is diagonally attacking the King of player #1
// along the line of sight in direction #3.
(define "DiagonalCheck"
    (or
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) #3) index: 0)) (mapEntry "Queen" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) #3) index: 0)) (mapEntry "Bishop" #2))
    )
)

// Definition: FileCheck
// Checks if a Queen or Rook of the 'mover' player is attacking the King of player #1 along a file (N/S).
(define "FileCheck"
    (or {
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) N) index: 0)) (mapEntry "Queen" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) S) index: 0)) (mapEntry "Queen" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) N) index: 0)) (mapEntry "Rook" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) S) index: 0)) (mapEntry "Rook" #2))
    })
)

// Definition: RankCheck
// Checks if a Queen or Rook of the 'mover' player is attacking the King of player #1 along a rank (E/W).
(define "RankCheck"
    (or {
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) E) index: 0)) (mapEntry "Queen" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) W) index: 0)) (mapEntry "Queen" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) E) index: 0)) (mapEntry "Rook" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) W) index: 0)) (mapEntry "Rook" #2))
    })
)

// Definition: KnightCheck
// Checks if a Knight of the 'mover' player is attacking the King of player #1
// from specific Knight-move directions (#3, #4).
(define "KnightCheck"
    (and {
        (= (mapEntry "Knight" #2) (what at:(ahead (ahead (where "King" #1) steps:2 #3) steps:1 #4)))
        (!= (ahead (where "King" #1) steps:2 #3) (ahead (ahead (where "King" #1) steps:2 #3) steps:1 #4))
        (!= (where "King" #1) (ahead (where "King" #1) steps:2 #3))
    })
)

// Definition: CheckType
// Determines the type of check (diagonal, file, rank, knight) on the 'next' player's King
// and issues the corresponding umpire message. This uses KingGravitatesTo... macros
// to distinguish short/long diagonal checks based on King's quadrant.
(define "CheckType"
    (and {
        
        (if
            (or
                ("DiagonalCheck" (next) (mover) SE)
                (and
                    (= (next) 2) // For player 2 (Black), SE diagonal is a backward diagonal
                    ("PawnDiagonalCheck" (next) (mover) SE)
                )
            )
            (and {
                (if "KingGravitatesToMainDiagonal" (note "Short diagonal check"))
                (if "KingGravitatesToAntiDiagonal" (note "Long diagonal check"))
            })
        )
        
        (if
            (or
                ("DiagonalCheck" (next) (mover) SW)
                (and
                    (= (next) 2) // For player 2 (Black), SW diagonal is a backward diagonal
                    ("PawnDiagonalCheck" (next) (mover) SW)
                )
            )
            (and {
                (if "KingGravitatesToMainDiagonal" (note "Long diagonal check"))
                (if "KingGravitatesToAntiDiagonal" (note "Short diagonal check"))
            })
        )
        
        (if
            (or
                ("DiagonalCheck" (next) (mover) NE)
                (and
                    (= (next) 1) // For player 1 (White), NE diagonal is a backward diagonal
                    ("PawnDiagonalCheck" (next) (mover) NE)
                )
            )
            (and {
                (if "KingGravitatesToMainDiagonal" (note "Long diagonal check"))
                (if "KingGravitatesToAntiDiagonal" (note "Short diagonal check"))
            })
        )
        
        (if
            (or
                ("DiagonalCheck" (next) (mover) NW)
                (and
                    (= (next) 1) // For player 1 (White), NW diagonal is a backward diagonal
                    ("PawnDiagonalCheck" (next) (mover) NW)
                )
            )
            (and {
                (if "KingGravitatesToMainDiagonal" (note "Short diagonal check"))
                (if "KingGravitatesToAntiDiagonal" (note "Long diagonal check"))
            })
        )
        
        (if ("FileCheck" (next) (mover)) (note "File check"))
        
        (if ("RankCheck" (next) (mover)) (note "Rank check"))
        
        (if
            (or {
                ("KnightCheck" (next) (mover) N E)
                ("KnightCheck" (next) (mover) N W)
                ("KnightCheck" (next) (mover) W N)
                ("KnightCheck" (next) (mover) W S)
                ("KnightCheck" (next) (mover) S W)
                ("KnightCheck" (next) (mover) S E)
                ("KnightCheck" (next) (mover) E S)
                ("KnightCheck" (next) (mover) E N)
                
            })
            (note "Knight Check")
        )
    })
)

// Definition: KingNextToOpposingKing
// Checks if the King of player #1 is adjacent to the King of player #2.
// This is used as a check condition (Kings cannot move next to each other).
(define "KingNextToOpposingKing"
    (or {
        (= (ahead (where "King" #1) steps:1 N) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 S) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 E) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 W) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 NE) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 NW) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 SE) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 SW) (where "King" #2))
    })
)

// Definition: KingInCheck
// The main check logic. Returns true if King of player #1 is threatened by player #2.
// Combines all specific check types.
(define "KingInCheck"
    (or {
        
        (or
            ("DiagonalCheck" #1 #2 SE)
            (and
                (= #1 2) // If player 2 (Black) is the King under check, pawns check from SE.
                ("PawnDiagonalCheck" #1 #2 SE)
            )
        )
        
        (or
            ("DiagonalCheck" #1 #2 SW)
            (and
                (= #1 2) // If player 2 (Black) is the King under check, pawns check from SW.
                ("PawnDiagonalCheck" #1 #2 SW)
            )
        )
        
        (or
            ("DiagonalCheck" #1 #2 NE)
            (and
                (= #1 1) // If player 1 (White) is the King under check, pawns check from NE.
                ("PawnDiagonalCheck" #1 #2 NE)
            )
        )
        
        (or
            ("DiagonalCheck" #1 #2 NW)
            (and
                (= #1 1) // If player 1 (White) is the King under check, pawns check from NW.
                ("PawnDiagonalCheck" #1 #2 NW)
            )
        )
        
        ("FileCheck" #1 #2)
        
        ("RankCheck" #1 #2)
        
        ("KnightCheck" #1 #2 N E)
        ("KnightCheck" #1 #2 N W)
        ("KnightCheck" #1 #2 W N)
        ("KnightCheck" #1 #2 W S)
        ("KnightCheck" #1 #2 S W)
        ("KnightCheck" #1 #2 S E)
        ("KnightCheck" #1 #2 E S)
        ("KnightCheck" #1 #2 E N)
        
        ("KingNextToOpposingKing" #1 #2)
    })
)

// Definition: CanPawnCapture
// Checks if a specific pawn (at 'value' from forEach loop) can legally capture diagonally in direction #1.
// Includes checking that the move does not leave its own King in check.
(define "CanPawnCapture"
    (and {
        (is Friend (who at:(ahead (value) #1))) 
        (can Move
            (do
                (move (from: (value)) (to: (ahead (value) #1)))
                ifAfterwards:(not ("KingInCheck" (next) (mover)))
            )
        )
    })
)

// Definition: CountTries
// Calculates and announces the number of legal pawn capturing moves for the 'Next' player.
// This is a specific umpire message in Kriegspiel.
(define "CountTries"
    (and {
        (set Score Next 0) // Reset 'tries' score for the next player
        (forEach Value min:1 max:63 // Iterate through all board sites (pawns are ID 1 or 2)
            (if (= (what at: (value)) (next)) // If the piece at current site 'value' belongs to 'Next' player
                (and {
                    (if
                        ("CanPawnCapture" FR)
                        (addScore Next 1) // Add 1 try if pawn can capture Forward-Right
                    )
                    (if
                        ("CanPawnCapture" FL)
                        (addScore Next 1) // Add 1 try if pawn can capture Forward-Left
                    )
                })
            )
        )
    })
)

// Definition: SafePassingLocation
// Checks if a specific location (#1) is empty and safe for the King to pass through during castling.
// A location is safe if the King won't be in check after moving there.
(define "SafePassingLocation"
    (and
        (is Empty (#1))
        (can Move
            (do
                (move
                    (from (where "King" Mover))
                    (to (#1))
                )
                ifAfterwards:(not ("KingInCheck" (mover) (next)))
            )
        )
    )
)

// Definition: KnightMovement
// Checks if the 'last To' location matches a standard Knight movement pattern from 'last From'.
// #1 and #2 are directions (e.g., N E for North then East).
(define "KnightMovement"
    (and {
        (= (last To) (ahead (ahead (last From) steps:2 #1) steps:1 #2))
        (!= (ahead (last From) steps:2 #1) (ahead (ahead (last From) steps:2 #1) steps:1 #2)) // Ensure the intermediate square isn't the same as the target
        (!= (last From) (ahead (last From) steps:2 #1)) // Ensure the intermediate square isn't the starting square
    })
)

// Definition: OrthogonalMovement
// Checks if 'last From' and 'last To' are aligned orthogonally (N, S, W, E)
// along a line of sight, typical for Rooks and Queens.
(define "OrthogonalMovement"
    (or {
        (= (regionSite (sites LineOfSight Piece at:(last To) N) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) S) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) W) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) E) index: 0) (last From))
    })
)

// Definition: DiagonalMovement
// Checks if 'last From' and 'last To' are aligned diagonally (NE, NW, SE, SW)
// along a line of sight, typical for Bishops and Queens.
(define "DiagonalMovement"
    (or {
        (= (regionSite (sites LineOfSight Piece at:(last To) NE) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) NW) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) SE) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) SW) index: 0) (last From))
    })
)

// Definition: KingMovement
// Checks if 'last To' is one step away in any direction from 'last From',
// typical for King movement.
(define "KingMovement"
    (or {
        (= (ahead (last From) steps:1 N) (last To))
        (= (ahead (last From) steps:1 S) (last To))
        (= (ahead (last From) steps:1 E) (last To))
        (= (ahead (last From) steps:1 W) (last To))
        (= (ahead (last From) steps:1 NE) (last To))
        (= (ahead (last From) steps:1 NW) (last To))
        (= (ahead (last From) steps:1 SE) (last To))
        (= (ahead (last From) steps:1 SW) (last To))
    })
)

// Definition: DecideToCastle
// Checks conditions for castling:
// 1. King moves 2 steps in direction #2 (E or W).
// 2. King is not currently in check, and doesn't pass through or land in check.
// 3. Both King and the specific Rook (#3, i.e., "RookRight" or "RookLeft") have never moved.
// 4. The target square is empty (additional empty square checks are in calling context).
(define "DecideToCastle"
    (and {
        (= (ahead (last From) steps:#1 #2) (last To)) // #1 is distance, #2 is direction
        (not ("KingInCheck" (mover) (next)))
        ("HasNeverMoved" "King")
        ("HasNeverMoved" #3)
        (is Empty (last To))
    })
)

// Definition: PawnStep
// Checks for a single-step forward pawn move to an empty square.
(define "PawnStep"
    (and
        (= (last To) (ahead (last From) steps: 1 Forward))
        (is Empty (last To))
    )
)

// Definition: InitialPawnMove
// Checks for an initial double-step forward pawn move.
// Conditions: from starting rank, target square is empty, and intermediate square is empty.
(define "InitialPawnMove"
    (and {
        (= (last To) (ahead (last From) steps: 2 Forward))
        (is Empty (last To))
        (is In (last From) (sites Start (piece (what at:(last From))))) // Is on its starting rank
        (or // Check if intermediate square is empty (by line of sight to source)
            (= (regionSite (sites LineOfSight Piece at:(last To) N) index: 0) (last From))
            (= (regionSite (sites LineOfSight Piece at:(last To) S) index: 0) (last From))
        )
    })
)

// Definition: MoveForwardDiagonal
// Checks for a diagonal pawn move (capture or en passant).
// Conditions: diagonal forward step, and target is an enemy piece OR en passant square.
(define "MoveForwardDiagonal"
    (and {
        (or
            (= (last To) (ahead (last From) steps: 1 FR))
            (= (last To) (ahead (last From) steps: 1 FL))
        )
        (or
            (is Enemy (who at:(last To))) // Normal capture
            (= (last To) (var "EnPassantLocation")) // En passant capture
        )
    })
)

// Definition: IsMovingPiece
// Helper macro: Checks if the piece at the 'last From' location is of the specified type (#1)
// and belongs to the 'Mover'.
(define "IsMovingPiece" 
    (= (what at: (last From)) (mapEntry #1 Mover))
)

// Definition: MovingTheKing
// Helper macro: Checks if the 'last From' location is the King's current position.
(define "MovingTheKing"
    (= (last From) (where "King" Mover))
)

// Definition: LegalMove
// This is the core umpire logic for validating if a given move (last From to last To) is legal.
// It checks two main things:
// 1. King Safety: The move must not leave the Mover's King in check after the move.
// 2. Geometric Rules: The move must adhere to the piece's specific movement rules.
// This macro is used by the umpire (Ludii engine) to verify attempted moves.
(define "LegalMove"
    (and
        // Condition 1: King safety check.
        // It simulates the move using 'do...ifAfterwards' and checks if the King is in check.
        (can Move
            (do
                (move (from (last From)) (to (last To)))
                ifAfterwards:(not ("KingInCheck" (mover) (next)))
            )
        )
        // Condition 2: Geometric rules for each piece type.
        (or {
            (and
                ("IsMovingPiece" "Pawn")
                (or {
                    "PawnStep"
                    "InitialPawnMove"
                    "MoveForwardDiagonal"
                })
            )
            (and
                ("IsMovingPiece" "Knight")
                (or {
                    ("KnightMovement" N E)
                    ("KnightMovement" N W)
                    ("KnightMovement" W N)
                    ("KnightMovement" W S)
                    ("KnightMovement" S E)
                    ("KnightMovement" S W)
                    ("KnightMovement" E N)
                    ("KnightMovement" E S)
                })
            )
            (and
                ("IsMovingPiece" "Queen")
                (or {
                    ("DiagonalMovement")
                    ("OrthogonalMovement")
                })
            )
            (and
                ("IsMovingPiece" "Rook")
                (or {
                    ("OrthogonalMovement")
                })
            )
            (and
                ("IsMovingPiece" "Bishop")
                (or {
                    ("DiagonalMovement")
                })
            )
            (and
                ("MovingTheKing")
                (or {
                    ("KingMovement")
                    (and {
                        ("DecideToCastle" 2 E "RookRight")
                        ("SafePassingLocation" (ahead (last From) steps: 1 E))
                    })
                    (and {
                        ("DecideToCastle" 2 W "RookLeft")
                        ("SafePassingLocation" (ahead (last From) steps: 1 W))
                        ("SafePassingLocation" (ahead (last From) steps: 2 W))
                    })
                })
            )
        })
    )
)

// Definition: CommonPostMoveActions
// Actions executed after any legal move has been performed.
// - Checks if the opponent's King is in check and announces the check type.
// - Sets a variable if the opponent is checkmated.
// - Sets a variable if a draw condition (stalemate or 50-move rule) is met.
// - Counts pawn capture "tries" for umpire announcements.
// - Calls "ResetIllegalMovesList" to clear the list of failed attempts,
//   as a legal move has successfully advanced the game state.
(define "CommonPostMoveActions"
    
    (if ("KingInCheck" (next) (mover))
        "CheckType"
    )
    
    (if (and ("KingInCheck" (next) (mover)) ("NextCanNotMove"))
        (set Var "NextLost" 1) // Opponent is checkmated
    )
    
    (if (or (and (not ("KingInCheck" (next) (mover))) ("NextCanNotMove")) (= (counter) 99))
        (set Var "DrawCondition" 1) // Stalemate or 50-move rule (counter 99 implies 100th move)
    )
    
    "CountTries"

    ("ResetIllegalMovesList") // Reset illegal moves list after a successful legal move
)

// Definition: SetEnPassantLocation
// Sets the 'EnPassantLocation' variable to the square behind the pawn that just moved two steps.
// This location becomes 'pending' for potential en passant capture by opponent.
(define "SetEnPassantLocation"
    (set Var "EnPassantLocation" (ahead (last To) Backward))
    (set Pending (ahead (last To) Backward))
)

// Definition: CountEnPassantTries
// Checks if either of the opponent's pawns can capture the current pawn via en passant.
// Adds to the 'tries' score for umpire announcement.
(define "CountEnPassantTries"
    (if (= (what at: (ahead (last To) Rightward)) (next))
        (addScore Next 1)
    )
    (if (= (what at: (ahead (last To) Leftward)) (next))
        (addScore Next 1)
    )
)

// Definition: PerformLegalMove
// This macro executes the effects of a legal move. It's a complex set of conditional
// blocks, each handling a specific type of legal move (pawn step, pawn capture, en passant,
// piece move, King move, castling).
// Crucially, it calls "ResetIllegalMovesList" before executing the actual move to ensure
// the list is always clean after a valid move, regardless of the sequence of actions.
(define "PerformLegalMove"
    (or {
        ("ResetIllegalMovesList") // Reset the illegal moves list at the beginning of processing a legal move
        
        // Pawn single step
        (if (and ("IsMovingPiece" "Pawn") ("PawnStep"))
            (move
                (from (last From))
                (to (last To))
                (then
                    (and {
                        (set Var "EnPassantLocation" -1) // Clear en passant eligibility
                        (if (is In (last To) (sites Mover "Promotion"))
                            (moveAgain) // If pawn reaches promotion rank, allow immediate promotion
                        )
                        "CommonPostMoveActions"
                        (set Counter) // Reset 50-move counter
                    })
                )
            )
        )
        // Pawn diagonal capture (normal)
        (if (and ("IsMovingPiece" "Pawn") (is Enemy (who at:(last To))))
            (and {
                ("ResetIllegalMovesList") // Reset in case it was not already cleared by the outer "PerformLegalMove" call
                (set Var "CapturedPiece" (what at:(last To))) // Store captured piece ID
                (move
                    (from (last From))
                    (to (last To))
                    (then
                        (and {
                            (set Var "EnPassantLocation" -1) // Clear en passant eligibility
                            ("NoteCapture" (last To) (var "CapturedPiece")) // Announce capture
                            (if (is In (last To) (sites Mover "Promotion"))
                                (moveAgain) // If pawn promotes, allow immediate promotion
                            )
                            "CommonPostMoveActions"
                            (set Counter) // Reset 50-move counter
                        })
                    )
                )
            })
        )
        // Pawn en passant capture
        (if (and ("IsMovingPiece" "Pawn") (= (last To) (var "EnPassantLocation")))
            (move
                (from (last From))
                (to (last To))
                (then
                    (and {
                        (set Var "CapturedPiece"(what at:(ahead (last To) Backward))) // Get captured pawn ID
                        (set Var "CaptureLocation" (ahead (last To) Backward)) // Get actual capture square
                        (remove
                            (ahead (last To) Backward) // Remove captured pawn
                            (then
                                (and {
                                    (set Var "EnPassantLocation" -1) // Clear en passant eligibility
                                    ("NoteCapture" (var "CaptureLocation") (var "CapturedPiece")) // Announce capture
                                    "CommonPostMoveActions"
                                    (set Counter) // Reset 50-move counter
                                })
                            )
                        )
                    })
                )
            )
        )
        // Pawn initial double step
        (if (and ("IsMovingPiece" "Pawn") ("InitialPawnMove"))
            (move
                (from (last From))
                (to (last To))
                (then
                    (and {
                        "SetEnPassantLocation" // Set en passant eligibility for opponent
                        "CommonPostMoveActions"
                        "CountEnPassantTries" // Count pawn tries for opponent
                        (set Counter) // Reset 50-move counter
                    })
                )
            )
        )
        // Knight, Queen, Rook, Bishop moves (capturing)
        (if (and
                (or {
                    ("IsMovingPiece" "Knight") ("IsMovingPiece" "Queen")
                    ("IsMovingPiece" "Rook") ("IsMovingPiece" "Bishop")
                })
                (is Enemy (who at:(last To))) // Target square occupied by enemy
            )
            (and
                (set Var "CapturedPiece" (what at:(last To))) // Store captured piece ID
                (move
                    (from (last From))
                    (to (last To))
                    (then
                        (and {
                            ("ResetIllegalMovesList") // Reset illegal moves list
                            (set Var "EnPassantLocation" -1) // Clear en passant eligibility
                            ("NoteCapture" (last To) (var "CapturedPiece")) // Announce capture
                            "CommonPostMoveActions"
                            ("PieceHasMoved" (last To)) // Set piece state as moved (not strictly needed for these pieces)
                            (set Counter) // Reset 50-move counter
                        })
                    )
                )
            )
        )
        // Knight, Queen, Rook, Bishop moves (to empty square)
        (if (and
                (or {
                    ("IsMovingPiece" "Knight") ("IsMovingPiece" "Queen")
                    ("IsMovingPiece" "Rook") ("IsMovingPiece" "Bishop")
                })
                (is Empty (last To)) // Target square is empty
            )
            (move
                (from (last From))
                (to (last To))
                (then
                    (and {
                        ("ResetIllegalMovesList") // Reset illegal moves list
                        (set Var "EnPassantLocation" -1) // Clear en passant eligibility
                        "CommonPostMoveActions"
                        ("PieceHasMoved" (last To)) // Set piece state as moved
                    })
                )
            )
        )
        // King move (capturing)
        (if (and ("MovingTheKing") (is Enemy (who at:(last To))))
            (and
                (set Var "CapturedPiece" (what at:(last To))) // Store captured piece ID
                (move
                    (from (last From))
                    (to (last To))
                    (then
                        (and {
                            ("ResetIllegalMovesList") // Reset illegal moves list
                            (set Var "EnPassantLocation" -1) // Clear en passant eligibility
                            ("NoteCapture" (last To) (var "CapturedPiece")) // Announce capture
                            "CommonPostMoveActions"
                            ("PieceHasMoved" (last To)) // Set King's state as moved
                            (set Counter) // Reset 50-move counter
                        })
                    )
                )
            )
        )
        // King move (to empty square)
        (if (and ("MovingTheKing") (is Empty (last To)))
            (move
                (from (last From))
                (to (last To))
                (then
                    (and {
                        ("ResetIllegalMovesList") // Reset illegal moves list
                        (set Var "EnPassantLocation" -1) // Clear en passant eligibility
                        "CommonPostMoveActions"
                        ("PieceHasMoved" (last To)) // Set King's state as moved
                    })
                )
            )
        )
        // King castling (Kingside - Right Rook)
        (if (and ("MovingTheKing") ("DecideToCastle" 2 E "RookRight"))
            (and
                (move (from (last From)) (to (last To)) (then ("PieceHasMoved" (last To)))) // Move King
                (move
                    (from (mapEntry "RookRight" (mover))) // Move Rook
                    (to (ahead (mapEntry "RookRight" (mover)) steps: 2 W))
                    (then
                        (and {
                            ("ResetIllegalMovesList") // Reset illegal moves list
                            (set Var "EnPassantLocation" -1) // Clear en passant eligibility
                            "CommonPostMoveActions"
                            ("PieceHasMoved" (ahead (mapEntry "RookRight" (mover)) steps: 2 W)) // Set Rook's state as moved
                        })
                    )
                )
            )
        )
        // King castling (Queenside - Left Rook)
        (if (and ("MovingTheKing") ("DecideToCastle" 2 W "RookLeft"))
            (and
                (move (from (last From)) (to (last To)) (then ("PieceHasMoved" (last To)))) // Move King
                (move
                    (from (mapEntry "RookLeft" (mover))) // Move Rook
                    (to (ahead (mapEntry "RookLeft" (mover)) steps: 3 E))
                    (then
                        (and {
                            ("ResetIllegalMovesList") // Reset illegal moves list
                            (set Var "EnPassantLocation" -1) // Clear en passant eligibility
                            "CommonPostMoveActions"
                            ("PieceHasMoved" (ahead (mapEntry "RookLeft" (mover)) steps: 3 E)) // Set Rook's state as moved
                        })
                    )
                )
            )
        )
    })
)

// Definition: InLocationEnPassant
// Checks if the 'to' location is the designated 'EnPassantLocation' and if it's currently pending.
(define "InLocationEnPassant"
    (and
        (is Pending)
        (= (to) (value Pending))
    )
)

// Definition: EnPassant
// Defines the geometric mechanics of an en passant capture move for pawn.
// This is used by "KriegspielPawn" to generate UI moves. Actual capture effect is in "PerformLegalMove".
(define "EnPassant"
    (move
        Step
        (directions {FR FL})
        (to if:"InLocationEnPassant")
        (then
            (remove
                (ahead (last To) Backward) // Remove the captured pawn (one square behind target)
            )
        )
    )
)

// Definition: CaptureForwardDiagonal
// Defines the geometric mechanics of a diagonal capture move, typically for pawns.
// This is used by "KriegspielPawn" to generate UI moves. Actual capture effect is in "PerformLegalMove".
(define "CaptureForwardDiagonal"
    (move
        Step
        (directions {FR FL})
        (to
            if:(is Enemy (who at:(to)))
            (apply
                (remove (to))
            )
        )
    )
)

// Definition: PromotionCondition
// Checks if the 'last To' location is a promotion square for the 'Mover'
// and if the piece at 'last To' is a Pawn of the 'Mover'.
(define "PromotionCondition"
    (and
        (is In (last To) (sites Mover "Promotion"))
        (= (what at: (last To)) (mapEntry "Pawn" Mover))
    )
)

// Definition: AttemptStepForward
// UI move generator for a single step forward, allows move to empty or enemy squares.
// The real legality (e.g., King safety, intermediate square for double step)
// is checked by "LegalMove".
(define "AttemptStepForward" 
    (move Step (directions Forward) (to if:(not (is Friend (who at:(to))))))
)

// Definition: AttemptDoubleStep
// UI move generator for a double step forward, allows move to empty or enemy squares.
// The real legality (e.g., being on starting rank, intermediate square being empty)
// is checked by "LegalMove".
(define "AttemptDoubleStep" 
    (move Slide (directions Forward) (between (exact 2)) (to if:(not (is Friend (who at:(to))))))
)

// Definition: AttemptCaptureForwardDiagonal
// UI move generator for a diagonal capture, allows move to empty or enemy squares.
// The real legality (e.g., enemy piece actually present, en passant conditions)
// is checked by "LegalMove".
(define "AttemptCaptureForwardDiagonal" 
    (move Step (directions {FR FL}) (to if:(not (is Friend (who at:(to))))))
)

// Definition: AttemptSlide
// UI move generator for sliding pieces (Rook, Bishop, Queen).
// It generates all squares along a line of sight until a friendly piece is encountered.
// Friendly pieces block, but are not included as selectable destinations.
(define "AttemptSlide"
    (move Select
        (from (from)) 
        // To: Calculate destination region for the selected piece.
        (to
            (sites Direction
                from:(from)
                #1  // Uses the direction passed as argument #1 (e.g., Orthogonal, Diagonal)
                // Stop at the first friendly piece encountered.
                stop:(is Friend (who at:(to)))
                // Do not include the friendly piece's square in clickable destinations.
                stopIncluded:False
            )
            // Final safety filter on the destination to ensure it's not a friendly piece.
            if:(not (is Friend (who at:(to))))
        )
    )
)

//------------------------------------------------------------------------------
// --- CUSTOM MACROS FOR KRIEGSPIEL MOVE GENERATION (FOR UI) ---
// These macros define how the UI should present moves to the player,
// using the "Attempt" logic that stops at the first piece encountered.
//------------------------------------------------------------------------------

// Adaptation for Rook
(define "KriegspielRook"
    (piece "Rook" Each 
        // Generates for the UI only geometrically valid moves along orthogonal lines,
        // stopping at the first piece (friendly or enemy).
        ("AttemptSlide" Orthogonal)
    )
)

// Adaptation for Bishop
(define "KriegspielBishop"
    (piece "Bishop" Each
        // Generates for the UI only moves along diagonals.
        ("AttemptSlide" Diagonal)
    )
)

// Adaptation for Queen
(define "KriegspielQueen"
    (piece "Queen" Each
        // Generates for the UI moves along both orthogonal and diagonal lines.
        ("AttemptSlide" (union Orthogonal Diagonal))
    )
)

// Adaptation for Knight
// Knight's move is a "Leap", so it doesn't need "AttemptSlide".
// It only generates moves to destination squares if they are not occupied by a friendly piece.
(define "KriegspielKnight"
    (piece "Knight" Each 
        (move Leap "KnightWalk" (to if:(not (is Friend (who at:(to))))))
    )
)

// Adaptation for King, with castling logic based on "Main Chator" pattern
(define "KriegspielKing"
    (piece "King" Each
        (or {
            // Option 1: Normal single-step move.
            (move Step All 
                (to if:(not (is Friend (who at:(to))))))

            // Option 2: Castling logic.
            // This entire block (if) is considered only if the selected square is actually the King's.
            (if (= (from) (where "King" Mover))
                (or {
                    // Sub-option 2a: Queenside Castling (long)
                    (if 
                        // Conditions for queenside castling
                        (and {
                            ("HasNeverMoved" "King")
                            ("HasNeverMoved" "RookLeft")
                            (is Empty (ahead (from) steps:1 W))
                            (is Empty (ahead (from) steps:2 W))
                            (is Empty (ahead (from) steps:3 W))
                        })
                        // If conditions are true, generate the move
                        (move
                            (from)
                            (to (ahead (from) steps:2 W))
                        )
                    )

                    // Sub-option 2b: Kingside Castling (short)
                    (if 
                        // Conditions for kingside castling
                        (and {
                            ("HasNeverMoved" "King")
                            ("HasNeverMoved" "RookRight")
                            (is Empty (ahead (from) steps:1 E))
                            (is Empty (ahead (from) steps:2 E))
                        })
                        // If conditions are true, generate the move
                        (move
                            (from)
                            (to (ahead (from) steps:2 E))
                        )
                    )
                })
            )
        })
    )
)

// Adaptation for Pawn
// Maintains custom logic for single step, double step, capture, and en passant for UI generation.
(define "KriegspielPawn"
    (piece "Pawn" Each
        (or {
            "AttemptStepForward"
            (if (is In (from) (sites Start (piece (what at:(from)))))
                "AttemptDoubleStep"
            )
            (if (> (score Mover) 0) "AttemptCaptureForwardDiagonal")
            "EnPassant"
        })
    )
)

// Definition: InsufficientMaterial
// Checks for draw conditions due to insufficient material to checkmate the opponent.
// Covers King vs King, King vs King+Bishop, King vs King+Knight, and King+Bishop vs King+Bishop (same color square).
(define "InsufficientMaterial"
    (or {
        // Case 1: King vs King
        (and {
            (= (count Pieces) 2)
            (= (count Pieces "King") 2)
        })
        
        // Case 2: King vs King and Bishop
        (and {
            (= (count Pieces) 3)
            (= (count Pieces "King") 2)
            (= (count Pieces "Bishop") 1)
        })
        
        // Case 3: King vs King and Knight
        (and {
            (= (count Pieces) 3)
            (= (count Pieces "King") 2)
            (= (count Pieces "Knight") 1)
        })
        
        // Case 4: King and Bishop vs King and Bishop (same color square)
        // Uses our new macro for cleaner check.
        (and {
            (= (count Pieces) 4)
            (= (count Pieces "King") 2)
            ("BishopsOnSameColor")
        })
    })
)

// Definition: BishopsOnSameColor
// This macro is true only if there are exactly two Bishops on the board
// and they are on squares of the same color (i.e., (row + column) parity is same).
(define "BishopsOnSameColor"
    (and
        (= (count Pieces "Bishop") 2)
        (= 
            // Parity of the first found Bishop's square
            (mod
                (+
                    (row of:(regionSite (sites Occupied by:All component:"Bishop") index:0))
                    (column of:(regionSite (sites Occupied by:All component:"Bishop") index:0))
                )
                2
            )
            // Parity of the second found Bishop's square
            (mod
                (+
                    (row of:(regionSite (sites Occupied by:All component:"Bishop") index:1))
                    (column of:(regionSite (sites Occupied by:All component:"Bishop") index:1))
                )
                2
            )
        )
    )
)

// Definition: ResetIllegalMovesList
// Clears the list of illegal moves for BOTH players.
// This is crucial because a legal move changes the game state, and previously
// illegal moves for the opponent might become legal (or vice versa).
// This macro should be called after any successful legal move.
(define "ResetIllegalMovesList"
    (and {
        (forget Value "IllegalMovesP1" All)
        (forget Value "IllegalMovesP2" All)
    })
)

// Definition: RememberIllegalMove
// Adds a failed move attempt to the current player's "blacklist" (IllegalMovesP1/P2).
// This prevents the UI from suggesting the same illegal move again in the current turn.
// Parameters: #1 = from_site_index, #2 = to_site_index (passed from outside)
//
// !!! KNOWN BUG IN LUDII ENGINE !!!
// Despite parameters #1 and #2 correctly containing the attempted move's (from, to) indices,
// the arithmetic expression `(+ (* (#1) 100) (#2))` often yields an incorrect or "stale"
// value (e.g., -1, or the ID of a previous illegal move).
// This implies a fundamental issue with how Ludii's engine evaluates expressions
// involving parameters and/or manages variable state in rapid, chained `moveAgain` contexts.
// The `RememberValue` primitive itself also shows signs of not correctly processing its `value` argument.
(define "RememberIllegalMove" 
    (and {
        (set Var "IllegalMoveID" (+ (* (#1) 100) (#2)))
        
        (note "DEBUG: Adding to blacklist:")
        (note "  - Mover:") (note (mover))
        (note "  - Move ID:") (note (var "IllegalMoveID"))
        (note "  - From (raw):") (note (#1)) 
        (note "  - To (raw):") (note (#2))  
        
        (if (= (mover) 1)
            (remember Value "IllegalMovesP1" (var "IllegalMoveID") unique:True)
        )
        (if (= (mover) 2)
            (remember Value "IllegalMovesP2" (var "IllegalMoveID") unique:True)
        )
        (note "DEBUG: Contents of 'IllegalMovesP1' after addition:")
        (forEach Site (sites (values Remembered "IllegalMovesP1"))
            (note (site))
        )
        (note "DEBUG: Contents of 'IllegalMovesP2' after addition:")
        (forEach Site (sites (values Remembered "IllegalMovesP2"))
            (note (site))
        )
    })
)

// Definition: GenerateValidMoves
// This macro generates the "valid" moves that the UI should display to the player.
// It combines the geometric move generation (using KriegspielPiece macros)
// with a filter to exclude moves already declared illegal by the umpire in this turn.
(define "GenerateValidMoves"
    (move Select
        // 1. FROM: The user can select any piece of their color.
        (from (sites Occupied by:Mover))

        // 2. TO: Calculate the valid destinations.
        (to 
            (sites To
                (do 
                    // Generate geometric moves for all pieces
                    (forEach Piece)
                    
                    // COMBINED FILTER: the move must satisfy BOTH conditions
                    ifAfterwards:(and {
                    
                        // Condition 1: The move must belong to the selected piece.
                        // (This was the original and correct condition)
                        (= (from) (last From))
                        
                        // Condition 2: The move must not be in the list of illegal moves.
                        // (This is the new logic, rewritten to be purely evaluative)
                        (if (= (mover) 1)
                            // If it's P1, check P1's list
                            (not 
                                (is In 
                                    (+ (* (last From) 100) (last To))
                                    (values Remembered "IllegalMovesP1")
                                )
                            )
                            // Otherwise, it's P2, so check P2's list
                            (not 
                                (is In 
                                    (+ (* (last From) 100) (last To))
                                    (values Remembered "IllegalMovesP2")
                                )
                                // !!! KNOWN BUG IN LUDII ENGINE !!!
                                // The calculation `(+ (* (last From) 100) (last To))`
                                // used here to check the blacklist can also be unstable,
                                // leading to the UI potentially blocking valid moves or
                                // showing already tried illegal moves.
                            )
                        )
                    })
                )
            )
        )
    )
)

// Definition: DebugLegalMove
// This macro provides extensive logging for the move validation process.
// It shows the attempted move, its calculated ID, the contents of the blacklist,
// and the results of the King safety and geometric checks.
//
// !!! KNOWN BUG IN LUDII ENGINE !!!
// The ID can be unstable (e.g., -1, or incorrect values)
// in the first few attempts of illegal moves after a game restart or legal move.
// This highlights the general state inconsistency within the engine.
(define "DebugLegalMove"
    (and {
        (note "--- DEBUG: Start Move Analysis ---")
        (note "Attempted Move:")
        (note "  - From:") (note (last From))
        (note "  - To:") (note (last To))
        (note "  - Piece (ID):") (note (what at:(last From)))
        (note "  - Player:") (note (mover))
        
        // ---- BLACKLIST DEBUG BLOCK ----
        (note "---")
        (note "DEBUG BLACKLIST (Combined ID):")
        
        // Calculate the ID that would be searched for
        (set Var "debug_combined_id"
            (+ (* (last From) 100) (last To))
        )
        (note "  - Combined ID Calculated for this move:")
        (note (var "debug_combined_id"))

        // Check which list is being used and print its contents
        (if (= (mover) 1)
            (and {
                (note "  - Checking 'IllegalMovesP1' list.")
                (note "  - List contents (elements):")
                // Iterate through the array and print each element
                (forEach Site (sites (values Remembered "IllegalMovesP1"))
                    (note (site))
                )
                (if (is In (var "debug_combined_id") (values Remembered "IllegalMovesP1"))
                    (note "  - RESULT: FOUND! Move should be blocked.")
                    (note "  - RESULT: NOT FOUND. Move is allowed (for now).")
                )
            })
            (and {
                (note "  - Checking 'IllegalMovesP2' list.")
                (note "  - List contents (elements):")
                 // Iterate through the array and print each element
                (forEach Site (sites (values Remembered "IllegalMovesP2"))
                    (note (site))
                )
                (if (is In (var "debug_combined_id") (values Remembered "IllegalMovesP2"))
                    (note "  - RESULT: FOUND! Move should be blocked.")
                    (note "  - RESULT: NOT FOUND. Move is allowed (for now).")
                )
            })
        )
        // ---- END BLACKLIST DEBUG BLOCK ----

        // ---- KING SAFETY CHECK DEBUG ----
        (note "---")
        (note "DEBUG King Safety Check:")
        (if 
            (can Move (do (move (from (last From)) (to (last To))) ifAfterwards:(not ("KingInCheck" (mover) (next)))))
            (note "  - RESULT: PASSED (King does not end up in check)")
            (note "  - RESULT: FAILED (King would end up in check)")
        )

        // ---- GEOMETRIC ANALYSIS DEBUG ----
        (note "---")
        (note "DEBUG Geometric Analysis:")
        (if "LegalMove"
            (note "  - RESULT: PASSED (Geometric correct)")
            (note "  - RESULT: FAILED (Geometric incorrect)")
        )

        (note "--- DEBUG: End Move Analysis ---")
    })
)
//------------------------------------------------------------------------------

(game "Kriegspiel (Refactored)"
    (players {(player N) (player S)}) // Two players, facing North and South
    (equipment {
        (board (square 8)) // Standard 8x8 square board

        // Piece definitions with their UI move generation logic
        ("KriegspielPawn")
        ("KriegspielRook")
        ("KriegspielKing")
        ("KriegspielBishop")
        ("KriegspielKnight")
        ("KriegspielQueen")
    
        // Maps for unique piece IDs and their initial coordinates/types
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "Queen" {(pair 1 11) (pair 2 12)})
        (map "Rook" {(pair 1 3) (pair 2 4)})
        (map "Bishop" {(pair 1 7) (pair 2 8)})
        (map "Knight" {(pair 1 9) (pair 2 10)})
        (map "Pawn" {(pair 1 1) (pair 2 2)})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) // Separate IDs for Rook castling tracking
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        
        // Regions for pawn promotion ranks
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules
        (start {
            // Initial piece placement for White (Pawn1, Rook1, Knight1, etc.)
            (place "Pawn1" (sites Row 1))
            (place "Rook1" {"A1" "H1"} state:1) // state:1 indicates "has never moved" for castling tracking
            (place "Knight1" {"B1" "G1"})
            (place "Bishop1" {"C1" "F1"})
            (place "Queen1" coord:"D1")
            (place "King1" coord:"E1" state:1) // state:1 indicates "has never moved" for castling tracking

            // Initial piece placement for Black (Pawn2, Rook2, Knight2, etc.)
            (place "Pawn2" (sites Row 6))
            (place "Rook2" {"A8" "H8"} state:1)
            (place "Knight2" {"B8" "G8"})
            (place "Bishop2" {"C8" "F8"})
            (place "Queen2" coord:"D8")
            (place "King2" coord:"E8" state:1)
            
            // Set initial hidden information for Kriegspiel:
            // Each player's pieces are hidden to the opponent.
            (set Hidden (sites Occupied by: Mover) to:Next)
            (set Hidden (sites Occupied by: Next) to:Mover)

            // !!! MISSING !!!: A (forget Value "IllegalMovesP1" All) and (forget Value "IllegalMovesP2" All)
            // should ideally be here to ensure the blacklist is empty at the start of each game,
            // preventing stale data from previous runs.
        })
        
        (play
            (and
                // Promotion Rule: If a pawn reaches promotion rank, allow immediate promotion.
                (if "PromotionCondition"
                    (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover
                        (then 
                            (and {
                                ("CommonPostMoveActions") // Apply post-move actions after promotion
                            })
                        )
                    )
                )
                // Main Game Loop:
                // This branch is taken if it's a new turn OR it's not a promotion scenario.
                (if 
                    (or
                        ("NewTurn")
                        (not "PromotionCondition")
                    )
                    // Step 1: Generate and allow player to select a move (filtered by UI rules).
                    ("GenerateValidMoves")
                    // THEN: This block acts as the umpire's arbitration logic.
                    (then
                        (and {
                            (set Var "NextLost" 0) // Reset opponent loss condition
                            (set Var "DrawCondition" 0) // Reset draw condition
                            
                            // ******************************************************
                            // *** DEBUG CALL ***
                            // Commented out by default to reduce log spam unless debugging needed.
                            // "DebugLegalMove" 
                            // ******************************************************
                            
                            // Step 2: Umpire's decision on the selected move (prioritized).
                            (priority
                                // Path 1: If the move is truly Legal (passes all chess rules).
                                (if "LegalMove"
                                    "PerformLegalMove" // Execute the legal move's consequences.
                                )
                                
                                // Path 2: If the move is Illegal (fails chess rules).
                                (and {
                                    (note "Illegal move") // Umpire announces "Illegal move" to the player.
                                    (moveAgain) // Player must move again (turn does not pass).
                                    // Remember the illegal move to prevent the UI from suggesting it again this turn.
                                    //
                                    // !!! KNOWN BUG IN LUDII ENGINE !!!
                                    // The `RememberIllegalMove` macro, despite receiving correct
                                    // `(last From)` and `(last To)` parameters, fails to correctly
                                    // calculate and store the `Move ID` due to internal engine
                                    // state inconsistencies (values are "stale" or corrupted during calculation).
                                    // This renders the illegal move blacklist ineffective.
                                    ("RememberIllegalMove" (last From) (last To)) 
                                })
                            )
                        })
                    )
                )
            )
        )
        
        (end {
            // Win condition: Checkmate (If opponent's King is lost)
            (if (= (var "NextLost") 1) (result Mover Win))
            
            // Draw Condition Block
            (if 
                (or {
                    // Cause 1: Stalemate or 50-move limit reached (as per DrawCondition var).
                    (= (var "DrawCondition") 1)
                    
                    // Cause 2: Threefold Repetition (currently commented out).
                    // (is Repeat Positional) 
                    
                    // Cause 3: Insufficient material to force a checkmate.
                    ("InsufficientMaterial")
                })
                (result Mover Draw)
            )
        })
    )
)

//------------------------------------------------------------------------------
// METADATA: Information about the game for Ludii application and AI.
(metadata
    (info
        {
        (description "In this game each player can see their own pieces, but not those of their opponent. For this reason, it is necessary to have a third person (or computer) act as an umpire, with full information about the progress of the game. Players attempt to move on their turns, and the umpire declares their attempts 'legal' or 'illegal'. If the move is illegal, the player tries again; if it is legal, that move stands. Each player is given information about checks and captures. Since the position of the opponent's pieces is unknown, Kriegspiel is a game of imperfect information. This version has been refactored to provide a constrained UI, where only geometrically valid moves can be attempted.")
        (aliases {"Blind Chess" "Wild 16"})
        (rules "The game is played with three boards, one for each player; the third is for the umpire (and spectators). Each opponent knows the exact position of just their own pieces, and does not know where the opponent's pieces are (but can keep track of how many there are). Only the umpire knows the position of the game. The game proceeds in the following way:
            The umpire announces:
            -'White's [or Black's] turn'.
            -'Pawn at (square) captured', when a pawn is captured. The square of the capture is announced, e.g. Pawn gone on d4, or Pawn captured on d4. (En passant captures are specifically announced as such.)
            -'Piece at (square) captured', when a piece is captured. The square of the capture is announced.
            -'Illegal move' when the attempted move is illegal, given the opponent's position. For example: moving the king into check; moving a queen, rook, bishop, or pawn through squares occupied by the opponent's pieces; advancing a pawn into a square occupied by the opponent's pieces; moving a piece under an absolute pin.
            -'Rank check'.
            -'File check'.
            -'Long-diagonal check' (the longer of the two diagonals, from the king's point of view).
            -'Short-diagonal check'.
            -'Knight check'.
            -'(number)  tries' (number of legal capturing moves using pawns).
            -'Checkmate', 'stalemate', 'draw by repetition', 'draw by insufficient force', '50-move draw'.
            Pawn promotions are not announced. The precise location of the checking piece is not announced (although it may be deduced).
        Illegal move attempts are not announced to the opponent.")
        (id "4185")
        (source "<a href=\"https://en.wikipedia.org/wiki/Kriegspiel_(chess)\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "2.4.0")
        (classification "board/war/replacement/checkmate/chess")
        (author "Henry Michael Temple")
        (credit "Nikola Novarlic")
        (date "1899")
        }
    )
    (graphics {
        (show Score Always " tries") // Always display pawn "tries" score.
        (piece Scale "Pawn" 0.825) // Scale pawn graphics
        (piece Families {"Defined" "Microsoft" "Pragmata" "Symbola"}) // Set piece graphic families
        (board Style Chess) // Apply Chess board style
    })
)