(define "NextCanNotMove"
    (not
        (can Move
            (do
                (forEach Piece Next)
                ifAfterwards:(not ("KingInCheck" (next)(mover)))
            )
        )
    )
)

(define "HasNeverMoved"
    (= (state at:(mapEntry #1 (mover))) 1)
)

(define "PieceHasMoved"
    (set State at:#1 0)
)

(define "InAttackerSite"
    (or {
        (= #1 (var "AttackerSite"))
        (= (+ 100 #1) (var "AttackerSite"))
        (= (+ 200 #1) (var "AttackerSite"))
    })
)

 (define "CanBeCapturedByPawn"
    (and {
        (= (what at:(ahead (#1) steps:1 #2)) (mapEntry "Pawn" Next))
        (can Move
            (do
                (move (from: (ahead (#1) steps:1 #2)) (to: (#1)))
                ifAfterwards: (not ("KingInCheck" (next) (mover)))
            )
        )
    })
)

(define "NoteCapture"
    (and {
        (if (and ("CanBeCapturedByPawn" #1 FL) ("CanBeCapturedByPawn" #1 FR))
            (set Var "AttackerSite" (+ 200 (#1)))
            
            (if (or ("CanBeCapturedByPawn" #1 FL) ("CanBeCapturedByPawn" #1 FR))
                (set Var "AttackerSite" (+ 100 (#1)))

                (set Var "AttackerSite" #1)
            )
        )
        (if (and (= (#1)(coord:"A1")) (<= (#2) 2)) (note "Pawn at A1 captured"))
        (if (and (= (#1)(coord:"A1")) (> (#2) 2)) (note "Piece at A1 captured"))
        (if (and (= (#1)(coord:"A2")) (<= (#2) 2)) (note "Pawn at A2 captured"))
        (if (and (= (#1)(coord:"A2")) (> (#2) 2)) (note "Piece at A2 captured"))
        (if (and (= (#1)(coord:"A3")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at A4 captured en passant")

                (note "Pawn at A3 captured")
            )
        )
        (if (and (= (#1)(coord:"A3")) (> (#2) 2)) (note "Piece at A3 captured"))
        (if (and (= (#1)(coord:"A4")) (<= (#2) 2)) (note "Pawn at A4 captured"))
        (if (and (= (#1)(coord:"A4")) (> (#2) 2)) (note "Piece at A4 captured"))
        (if (and (= (#1)(coord:"A5")) (<= (#2) 2)) (note "Pawn at A5 captured"))
        (if (and (= (#1)(coord:"A5")) (> (#2) 2)) (note "Piece at A5 captured"))
        (if (and (= (#1)(coord:"A6")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at A5 captured en passant")

                (note "Pawn at A6 captured")
            )
        )
        (if (and (= (#1)(coord:"A6")) (> (#2) 2)) (note "Piece at A6 captured"))
        (if (and (= (#1)(coord:"A7")) (<= (#2) 2)) (note "Pawn at A7 captured"))
        (if (and (= (#1)(coord:"A7")) (> (#2) 2)) (note "Piece at A7 captured"))
        (if (and (= (#1)(coord:"A8")) (<= (#2) 2)) (note "Pawn at A8 captured"))
        (if (and (= (#1)(coord:"A8")) (> (#2) 2)) (note "Piece at A8 captured"))
        (if (and (= (#1)(coord:"B1")) (<= (#2) 2)) (note "Pawn at B1 captured"))
        (if (and (= (#1)(coord:"B1")) (> (#2) 2)) (note "Piece at B1 captured"))
        (if (and (= (#1)(coord:"B2")) (<= (#2) 2)) (note "Pawn at B2 captured"))
        (if (and (= (#1)(coord:"B2")) (> (#2) 2)) (note "Piece at B2 captured"))
        (if (and (= (#1)(coord:"B3")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at B4 captured en passant")

                (note "Pawn at B3 captured")
            )
        )
        (if (and (= (#1)(coord:"B3")) (> (#2) 2)) (note "Piece at B3 captured"))
        (if (and (= (#1)(coord:"B4")) (<= (#2) 2)) (note "Pawn at B4 captured"))
        (if (and (= (#1)(coord:"B4")) (> (#2) 2)) (note "Piece at B4 captured"))
        (if (and (= (#1)(coord:"B5")) (<= (#2) 2)) (note "Pawn at B5 captured"))
        (if (and (= (#1)(coord:"B5")) (> (#2) 2)) (note "Piece at B5 captured"))
        (if (and (= (#1)(coord:"B6")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at B5 captured en passant")

                (note "Pawn at B6 captured")
            )
        )
        (if (and (= (#1)(coord:"B6")) (> (#2) 2)) (note "Piece at B6 captured"))
        (if (and (= (#1)(coord:"B7")) (<= (#2) 2)) (note "Pawn at B7 captured"))
        (if (and (= (#1)(coord:"B7")) (> (#2) 2)) (note "Piece at B7 captured"))
        (if (and (= (#1)(coord:"B8")) (<= (#2) 2)) (note "Pawn at B8 captured"))
        (if (and (= (#1)(coord:"B8")) (> (#2) 2)) (note "Piece at B8 captured"))
        (if (and (= (#1)(coord:"C1")) (<= (#2) 2)) (note "Pawn at C1 captured"))
        (if (and (= (#1)(coord:"C1")) (> (#2) 2)) (note "Piece at C1 captured"))
        (if (and (= (#1)(coord:"C2")) (<= (#2) 2)) (note "Pawn at C2 captured"))
        (if (and (= (#1)(coord:"C2")) (> (#2) 2)) (note "Piece at C2 captured"))
        (if (and (= (#1)(coord:"C3")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at C4 captured en passant")

                (note "Pawn at C3 captured")
            )
        )
        (if (and (= (#1)(coord:"C3")) (> (#2) 2)) (note "Piece at C3 captured"))
        (if (and (= (#1)(coord:"C4")) (<= (#2) 2)) (note "Pawn at C4 captured"))
        (if (and (= (#1)(coord:"C4")) (> (#2) 2)) (note "Piece at C4 captured"))
        (if (and (= (#1)(coord:"C5")) (<= (#2) 2)) (note "Pawn at C5 captured"))
        (if (and (= (#1)(coord:"C5")) (> (#2) 2)) (note "Piece at C5 captured"))
        (if (and (= (#1)(coord:"C6")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at C5 captured en passant")

                (note "Pawn at C6 captured")
            )
        )
        (if (and (= (#1)(coord:"C6")) (> (#2) 2)) (note "Piece at C6 captured"))
        (if (and (= (#1)(coord:"C7")) (<= (#2) 2)) (note "Pawn at C7 captured"))
        (if (and (= (#1)(coord:"C7")) (> (#2) 2)) (note "Piece at C7 captured"))
        (if (and (= (#1)(coord:"C8")) (<= (#2) 2)) (note "Pawn at C8 captured"))
        (if (and (= (#1)(coord:"C8")) (> (#2) 2)) (note "Piece at C8 captured"))
        (if (and (= (#1)(coord:"D1")) (<= (#2) 2)) (note "Pawn at D1 captured"))
        (if (and (= (#1)(coord:"D1")) (> (#2) 2)) (note "Piece at D1 captured"))
        (if (and (= (#1)(coord:"D2")) (<= (#2) 2)) (note "Pawn at D2 captured"))
        (if (and (= (#1)(coord:"D2")) (> (#2) 2)) (note "Piece at D2 captured"))
        (if (and (= (#1)(coord:"D3")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at D4 captured en passant")

                (note "Pawn at D3 captured")
            )
        )
        (if (and (= (#1)(coord:"D3")) (> (#2) 2)) (note "Piece at D3 captured"))
        (if (and (= (#1)(coord:"D4")) (<= (#2) 2)) (note "Pawn at D4 captured"))
        (if (and (= (#1)(coord:"D4")) (> (#2) 2)) (note "Piece at D4 captured"))
        (if (and (= (#1)(coord:"D5")) (<= (#2) 2)) (note "Pawn at D5 captured"))
        (if (and (= (#1)(coord:"D5")) (> (#2) 2)) (note "Piece at D5 captured"))
        (if (and (= (#1)(coord:"D6")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at D5 captured en passant")

                (note "Pawn at D6 captured")
            )
        )
        (if (and (= (#1)(coord:"D6")) (> (#2) 2)) (note "Piece at D6 captured"))
        (if (and (= (#1)(coord:"D7")) (<= (#2) 2)) (note "Pawn at D7 captured"))
        (if (and (= (#1)(coord:"D7")) (> (#2) 2)) (note "Piece at D7 captured"))
        (if (and (= (#1)(coord:"D8")) (<= (#2) 2)) (note "Pawn at D8 captured"))
        (if (and (= (#1)(coord:"D8")) (> (#2) 2)) (note "Piece at D8 captured"))
        (if (and (= (#1)(coord:"E1")) (<= (#2) 2)) (note "Pawn at E1 captured"))
        (if (and (= (#1)(coord:"E1")) (> (#2) 2)) (note "Piece at E1 captured"))
        (if (and (= (#1)(coord:"E2")) (<= (#2) 2)) (note "Pawn at E2 captured"))
        (if (and (= (#1)(coord:"E2")) (> (#2) 2)) (note "Piece at E2 captured"))
        (if (and (= (#1)(coord:"E3")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at E4 captured en passant")

                (note "Pawn at E3 captured")
            )
        )
        (if (and (= (#1)(coord:"E3")) (> (#2) 2)) (note "Piece at E3 captured"))
        (if (and (= (#1)(coord:"E4")) (<= (#2) 2)) (note "Pawn at E4 captured"))
        (if (and (= (#1)(coord:"E4")) (> (#2) 2)) (note "Piece at E4 captured"))
        (if (and (= (#1)(coord:"E5")) (<= (#2) 2)) (note "Pawn at E5 captured"))
        (if (and (= (#1)(coord:"E5")) (> (#2) 2)) (note "Piece at E5 captured"))
        (if (and (= (#1)(coord:"E6")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at E5 captured en passant")

                (note "Pawn at E6 captured")
            )
        )
        (if (and (= (#1)(coord:"E6")) (> (#2) 2)) (note "Piece at E6 captured"))
        (if (and (= (#1)(coord:"E7")) (<= (#2) 2)) (note "Pawn at E7 captured"))
        (if (and (= (#1)(coord:"E7")) (> (#2) 2)) (note "Piece at E7 captured"))
        (if (and (= (#1)(coord:"E8")) (<= (#2) 2)) (note "Pawn at E8 captured"))
        (if (and (= (#1)(coord:"E8")) (> (#2) 2)) (note "Piece at E8 captured"))
        (if (and (= (#1)(coord:"F1")) (<= (#2) 2)) (note "Pawn at F1 captured"))
        (if (and (= (#1)(coord:"F1")) (> (#2) 2)) (note "Piece at F1 captured"))
        (if (and (= (#1)(coord:"F2")) (<= (#2) 2)) (note "Pawn at F2 captured"))
        (if (and (= (#1)(coord:"F2")) (> (#2) 2)) (note "Piece at F2 captured"))
        (if (and (= (#1)(coord:"F3")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at F4 captured en passant")

                (note "Pawn at F3 captured")
            )
        )
        (if (and (= (#1)(coord:"F3")) (> (#2) 2)) (note "Piece at F3 captured"))
        (if (and (= (#1)(coord:"F4")) (<= (#2) 2)) (note "Pawn at F4 captured"))
        (if (and (= (#1)(coord:"F4")) (> (#2) 2)) (note "Piece at F4 captured"))
        (if (and (= (#1)(coord:"F5")) (<= (#2) 2)) (note "Pawn at F5 captured"))
        (if (and (= (#1)(coord:"F5")) (> (#2) 2)) (note "Piece at F5 captured"))
        (if (and (= (#1)(coord:"F6")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at F5 captured en passant")

                (note "Pawn at F6 captured")
            )
        )
        (if (and (= (#1)(coord:"F6")) (> (#2) 2)) (note "Piece at F6 captured"))
        (if (and (= (#1)(coord:"F7")) (<= (#2) 2)) (note "Pawn at F7 captured"))
        (if (and (= (#1)(coord:"F7")) (> (#2) 2)) (note "Piece at F7 captured"))
        (if (and (= (#1)(coord:"F8")) (<= (#2) 2)) (note "Pawn at F8 captured"))
        (if (and (= (#1)(coord:"F8")) (> (#2) 2)) (note "Piece at F8 captured"))
        (if (and (= (#1)(coord:"G1")) (<= (#2) 2)) (note "Pawn at G1 captured"))
        (if (and (= (#1)(coord:"G1")) (> (#2) 2)) (note "Piece at G1 captured"))
        (if (and (= (#1)(coord:"G2")) (<= (#2) 2)) (note "Pawn at G2 captured"))
        (if (and (= (#1)(coord:"G2")) (> (#2) 2)) (note "Piece at G2 captured"))
        (if (and (= (#1)(coord:"G3")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at G4 captured en passant")

                (note "Pawn at G3 captured")
            )
        )
        (if (and (= (#1)(coord:"G3")) (> (#2) 2)) (note "Piece at G3 captured"))
        (if (and (= (#1)(coord:"G4")) (<= (#2) 2)) (note "Pawn at G4 captured"))
        (if (and (= (#1)(coord:"G4")) (> (#2) 2)) (note "Piece at G4 captured"))
        (if (and (= (#1)(coord:"G5")) (<= (#2) 2)) (note "Pawn at G5 captured"))
        (if (and (= (#1)(coord:"G5")) (> (#2) 2)) (note "Piece at G5 captured"))
        (if (and (= (#1)(coord:"G6")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at G5 captured en passant")

                (note "Pawn at G6 captured")
            )
        )
        (if (and (= (#1)(coord:"G6")) (> (#2) 2)) (note "Piece at G6 captured"))
        (if (and (= (#1)(coord:"G7")) (<= (#2) 2)) (note "Pawn at G7 captured"))
        (if (and (= (#1)(coord:"G7")) (> (#2) 2)) (note "Piece at G7 captured"))
        (if (and (= (#1)(coord:"G8")) (<= (#2) 2)) (note "Pawn at G8 captured"))
        (if (and (= (#1)(coord:"G8")) (> (#2) 2)) (note "Piece at G8 captured"))
        (if (and (= (#1)(coord:"H1")) (<= (#2) 2)) (note "Pawn at H1 captured"))
        (if (and (= (#1)(coord:"H1")) (> (#2) 2)) (note "Piece at H1 captured"))
        (if (and (= (#1)(coord:"H2")) (<= (#2) 2)) (note "Pawn at H2 captured"))
        (if (and (= (#1)(coord:"H2")) (> (#2) 2)) (note "Piece at H2 captured"))
        (if (and (= (#1)(coord:"H3")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at H4 captured en passant")

                (note "Pawn at H3 captured")
            )
        )
        (if (and (= (#1)(coord:"H3")) (> (#2) 2)) (note "Piece at H3 captured"))
        (if (and (= (#1)(coord:"H4")) (<= (#2) 2)) (note "Pawn at H4 captured"))
        (if (and (= (#1)(coord:"H4")) (> (#2) 2)) (note "Piece at H4 captured"))
        (if (and (= (#1)(coord:"H5")) (<= (#2) 2)) (note "Pawn at H5 captured"))
        (if (and (= (#1)(coord:"H5")) (> (#2) 2)) (note "Piece at H5 captured"))
        (if (and (= (#1)(coord:"H6")) (<= (#2) 2)) 
            (if (= #1 (var "EnPassantSite")) 
                (note "Pawn at H5 captured en passant")

                (note "Pawn at H6 captured")
            )
        )
        (if (and (= (#1)(coord:"H6")) (> (#2) 2)) (note "Piece at H6 captured"))
        (if (and (= (#1)(coord:"H7")) (<= (#2) 2)) (note "Pawn at H7 captured"))
        (if (and (= (#1)(coord:"H7")) (> (#2) 2)) (note "Piece at H7 captured"))
        (if (and (= (#1)(coord:"H8")) (<= (#2) 2)) (note "Pawn at H8 captured"))
        (if (and (= (#1)(coord:"H8")) (> (#2) 2)) (note "Piece at H8 captured"))
    })
)

(define "KingGravitatesToMainDiagonal"
    (not (xor (< (row of:(where "King" Next)) 4) (< (column of:(where "King" Next)) 4)))
)

(define "KingGravitatesToAntiDiagonal"
    (xor (< (row of:(where "King" Next)) 4) (< (column of:(where "King" Next)) 4))
)

(define "PawnDiagonalCheck"
    (= (what at: (ahead (where "King" #1) steps:1 #3)) (mapEntry "Pawn" #2))
)

(define "DiagonalCheck"
    (or
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) #3) index: 0)) (mapEntry "Queen" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) #3) index: 0)) (mapEntry "Bishop" #2))
    )
)

(define "FileCheck"
    (or {
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) N) index: 0)) (mapEntry "Queen" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) S) index: 0)) (mapEntry "Queen" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) N) index: 0)) (mapEntry "Rook" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) S) index: 0)) (mapEntry "Rook" #2))
    })
)

(define "RankCheck"
    (or {
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) E) index: 0)) (mapEntry "Queen" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) W) index: 0)) (mapEntry "Queen" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) E) index: 0)) (mapEntry "Rook" #2))
        (= (what at:(regionSite (sites LineOfSight Piece at:(where "King" #1) W) index: 0)) (mapEntry "Rook" #2))
    })
)

(define "KnightCheck"
    (and {
        (= (mapEntry "Knight" #2) (what at:(ahead (ahead (where "King" #1) steps:2 #3) steps:1 #4)))
        (!= (ahead (where "King" #1) steps:2 #3) (ahead (ahead (where "King" #1) steps:2 #3) steps:1 #4))
        (!= (where "King" #1) (ahead (where "King" #1) steps:2 #3))
    })
)

(define "KnightSiteValid"
    (and { 
        (>= (+ (where "King" (next)) #1) 0) 
        (<= (+ (where "King" (next)) #1) 63) 
        (= (abs (- (% (+ (where "King" (next)) #1) 8) (% (where "King" (next)) 8))) #2)
    })
)

(define "KnightSiteIfValid"
    (if ("KnightSiteValid" #1 #2) (sites {(ahead (ahead (where "King" (next)) steps:#3 #4) steps:#5 #6)}))
)

(define "CheckLineSites"
    (sites Direction from:(where "King" (next)) #1 stop:(is Enemy (who at:(to))) stopIncluded:False)
)

(define "TerminalSiteIndex"
    (- (count Sites in:("CheckLineSites" #1)) 1)
)

(define "ProcessCheck" 
    (if (#2)
        (forEach Site 
            (difference
                (union {
                    ("KnightSiteIfValid" 17 1 2 N 1 E)
                    ("KnightSiteIfValid" 15 1 2 N 1 W)
                    ("KnightSiteIfValid" -15 1 2 S 1 E)
                    ("KnightSiteIfValid" -17 1 2 S 1 W)
                    ("KnightSiteIfValid" 10 2 1 N 2 E)
                    ("KnightSiteIfValid" 6 2 1 N 2 W)
                    ("KnightSiteIfValid" -6 2 1 S 2 E)
                    ("KnightSiteIfValid" -10 2 1 S 2 W)
                })
                (sites Occupied by:Next)
            )
            
            (remember Value "CheckSites" (+ 100 (site)) unique:True)
        )

        (if (!= (count Sites in:("CheckLineSites" #1)) 0)
            (forEach Site ("CheckLineSites" #1)
                (if (= (site) (regionSite ("CheckLineSites" #1) index:("TerminalSiteIndex" #1)))
                    (remember Value "CheckSites" (+ 100 (site)) unique:True)

                    (remember Value "CheckSites" (site) unique:True)
                )
            )
        )
    )
)

(define "CheckType"
    (and {
        (if
            (or {
                ("DiagonalCheck" (next) (mover) SE)
                (and (= (next) 2) ("PawnDiagonalCheck" (next) (mover) SE))
                ("DiagonalCheck" (next) (mover) NW)
                (and (= (next) 1) ("PawnDiagonalCheck" (next) (mover) NW))
            })
            (and {
                ("ProcessCheck" SE (toBool 0))
                ("ProcessCheck" NW (toBool 0))
                (if "KingGravitatesToMainDiagonal" (note "Short diagonal check"))
                (if "KingGravitatesToAntiDiagonal" (note "Long diagonal check"))
            })
        )
        (if
            (or {
                ("DiagonalCheck" (next) (mover) SW)
                (and (= (next) 2) ("PawnDiagonalCheck" (next) (mover) SW))
                ("DiagonalCheck" (next) (mover) NE)
                (and (= (next) 1) ("PawnDiagonalCheck" (next) (mover) NE))
            })
            (and {
                ("ProcessCheck" SW (toBool 0))
                ("ProcessCheck" NE (toBool 0))
                (if "KingGravitatesToMainDiagonal" (note "Long diagonal check"))
                (if "KingGravitatesToAntiDiagonal" (note "Short diagonal check"))
            })
        )
        (if ("FileCheck" (next) (mover)) 
            (and {
                ("ProcessCheck" N (toBool 0))
                ("ProcessCheck" S (toBool 0))
                (note "File check")
            })
        )
        (if ("RankCheck" (next) (mover))
            (and {
                ("ProcessCheck" E (toBool 0))
                ("ProcessCheck" W (toBool 0))
                (note "Rank check")
            })
        )
        (if
            (or {
                ("KnightCheck" (next) (mover) N E)
                ("KnightCheck" (next) (mover) N W)
                ("KnightCheck" (next) (mover) W N)
                ("KnightCheck" (next) (mover) W S)
                ("KnightCheck" (next) (mover) S W)
                ("KnightCheck" (next) (mover) S E)
                ("KnightCheck" (next) (mover) E S)
                ("KnightCheck" (next) (mover) E N)
            })
            (and ("ProcessCheck" N (toBool 1)) (note "Knight Check"))
        )
    })
)

(define "KingNextToOpposingKing"
    (or {
        (= (ahead (where "King" #1) steps:1 N) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 S) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 E) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 W) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 NE) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 NW) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 SE) (where "King" #2))
        (= (ahead (where "King" #1) steps:1 SW) (where "King" #2))
    })
)

(define "KingInCheck"
    (or {
        (or
            ("DiagonalCheck" #1 #2 SE)
            (and
                (= #1 2)
                ("PawnDiagonalCheck" #1 #2 SE)
            )
        )
        (or
            ("DiagonalCheck" #1 #2 SW)
            (and
                (= #1 2)
                ("PawnDiagonalCheck" #1 #2 SW)
            )
        )
        (or
            ("DiagonalCheck" #1 #2 NE)
            (and
                (= #1 1)
                ("PawnDiagonalCheck" #1 #2 NE)
            )
        )
        (or
            ("DiagonalCheck" #1 #2 NW)
            (and
                (= #1 1)
                ("PawnDiagonalCheck" #1 #2 NW)
            )
        )
        ("FileCheck" #1 #2)
        ("RankCheck" #1 #2)
        ("KnightCheck" #1 #2 N E)
        ("KnightCheck" #1 #2 N W)
        ("KnightCheck" #1 #2 W N)
        ("KnightCheck" #1 #2 W S)
        ("KnightCheck" #1 #2 S W)
        ("KnightCheck" #1 #2 S E)
        ("KnightCheck" #1 #2 E S)
        ("KnightCheck" #1 #2 E N)
        ("KingNextToOpposingKing" #1 #2)
    })
)

(define "CanPawnCapture"
    (and
        (is Friend (who at:(ahead (value) #1)))
        (can Move
            (do
                (move (from: (value)) (to: (ahead (value) #1)))
                ifAfterwards:(not ("KingInCheck" (next) (mover)))
            )
        )
    )
)

(define "CountTries"
    (and
        (set Score Next 0)
        (forEach Value min:1 max:63
            (if (= (what at: (value)) (next))
                (and
                    (if ("CanPawnCapture" FR)
                        (addScore Next 1)
                    )
                    (if ("CanPawnCapture" FL)
                        (addScore Next 1)
                    )
                )
            )
        )
    )
)

(define "SafePassingLocation"
    (and
        (is Empty (#1))
        (can Move
            (do
                (move
                    (from (where "King" Mover))
                    (to (#1))
                )
                ifAfterwards:(not ("KingInCheck" (mover) (next)))
            )
        )
    )
)

(define "KnightMovement"
    (and {
        (= (last To) (ahead (ahead (last From) steps:2 #1) steps:1 #2))
        (!= (ahead (last From) steps:2 #1) (ahead (ahead (last From) steps:2 #1) steps:1 #2))
        (!= (last From) (ahead (last From) steps:2 #1))
    })
)

(define "OrthogonalMovement"
    (or {
        (= (regionSite (sites LineOfSight Piece at:(last To) N) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) S) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) W) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) E) index: 0) (last From))
    })
)

(define "DiagonalMovement"
    (or {
        (= (regionSite (sites LineOfSight Piece at:(last To) NE) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) NW) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) SE) index: 0) (last From))
        (= (regionSite (sites LineOfSight Piece at:(last To) SW) index: 0) (last From))
    })
)

(define "KingMovement"
    (or {
        (= (ahead (last From) steps:1 N) (last To))
        (= (ahead (last From) steps:1 S) (last To))
        (= (ahead (last From) steps:1 E) (last To))
        (= (ahead (last From) steps:1 W) (last To))
        (= (ahead (last From) steps:1 NE) (last To))
        (= (ahead (last From) steps:1 NW) (last To))
        (= (ahead (last From) steps:1 SE) (last To))
        (= (ahead (last From) steps:1 SW) (last To))
    })
)

(define "DecideToCastle"
    (and {
        (= (ahead (last From) steps:2 #1) (last To))
        (not ("KingInCheck" (mover) (next)))
        ("HasNeverMoved" "King")
        ("HasNeverMoved" #2)
        (is Empty (last To))
        ("SafePassingLocation" (ahead (last From) steps: 1 #1))
        ("SafePassingLocation" (ahead (last From) steps: 2 #1))
    })
)

(define "PawnStep"
    (and
        (= (last To) (ahead (last From) steps: 1 Forward))
        (is Empty (last To))
    )
)

(define "InitialPawnMove"
    (and {
        (= (last To) (ahead (last From) steps: 2 Forward))
        (is Empty (last To))
        (is In (last From) (sites Start (piece (what at:(last From)))))
        (or
            (= (regionSite (sites LineOfSight Piece at:(last To) N) index: 0) (last From))
            (= (regionSite (sites LineOfSight Piece at:(last To) S) index: 0) (last From))
        )
    })
)

(define "MoveForwardDiagonal"
    (and {
        (or
            (= (last To) (ahead (last From) steps: 1 FR))
            (= (last To) (ahead (last From) steps: 1 FL))
        )
        (or
            (is Enemy (who at:(last To)))
            (= (last To) (var "EnPassantSite"))
        )
    })
)

(define "IsMovingPiece"
    (= (what at: (last From)) (mapEntry #1 Mover))
)

(define "MovingTheKing"
    (= (last From) (where "King" Mover))
)

(define "LegalMove"
    (and
        (can Move
            (do
                (move (from (last From)) (to (last To)))
                ifAfterwards:(not ("KingInCheck" (mover) (next)))
            )
        )
        (or {
            (and
                ("IsMovingPiece" "Pawn")
                (or {
                    "PawnStep"
                    "InitialPawnMove"
                    "MoveForwardDiagonal"
                })
            )
            (and
                ("IsMovingPiece" "Knight")
                (or {
                    ("KnightMovement" N E)
                    ("KnightMovement" N W)
                    ("KnightMovement" W N)
                    ("KnightMovement" W S)
                    ("KnightMovement" S E)
                    ("KnightMovement" S W)
                    ("KnightMovement" E N)
                    ("KnightMovement" E S)
                })
            )
            (and
                ("IsMovingPiece" "Queen")
                (or ("DiagonalMovement") ("OrthogonalMovement"))
            )
            (and ("IsMovingPiece" "Rook") ("OrthogonalMovement"))
            (and ("IsMovingPiece" "Bishop") ("DiagonalMovement"))
            (and 
                ("MovingTheKing")
                (or {
                    ("KingMovement")
                    ("DecideToCastle" E "RookRight")
                    (and ("DecideToCastle" W "RookLeft") (is Empty (ahead (last From) steps: 3 W)))
                })
            )
        })
    )
)

(define "OnlyKingsRemaining"
    (and {
        (= (count Pieces) 2)
        (= (count Pieces "King") 2)
    })
)

(define "KingVsKingAndSingleBishop"
    (and {
        (= (count Pieces) 3)
        (= (count Pieces "King") 2)
        (= (count Pieces "Bishop") 1)
    })
)

(define "KingVsKingAndSingleKnight"
    (and {
        (= (count Pieces) 3)
        (= (count Pieces "King") 2)
        (= (count Pieces "Knight") 1)
    })
)

(define "KingsAndBishopsSameColor"
    (and {
        (= (count Pieces) 4)
        (= (count Pieces "King") 2)
        (= (count Pieces "Bishop") 2)
        (= (count Pieces P1 "Bishop") 1)
        (= (count Pieces P2 "Bishop") 1)
        (= (% (+ (row of:(where "Bishop" P1)) (column of:(where "Bishop" P1))) 2)
           (% (+ (row of:(where "Bishop" P2)) (column of:(where "Bishop" P2))) 2))
    })
)

(define "CommonPostMoveActions"
    (and {
        (if ("KingInCheck" (next) (mover)) (and "CheckType" (if ("NextCanNotMove") (set Var "NextLost" 1))))
        (if (and ("NextCanNotMove") (not ("KingInCheck" (next) (mover)))) (and (set Var "DrawCondition" 1) (note "Draw by stalemate")))
        (if (is Repeat Positional) (and (set Var "DrawCondition" 2) (note "Draw by repetition threefold")))
        (if "OnlyKingsRemaining" (and (set Var "DrawCondition" 3) (note "Draw by insufficient force kings only")))
        (if "KingVsKingAndSingleBishop" (and (set Var "DrawCondition" 4) (note "Draw by insufficient force king and bishop vs king")))            
        (if "KingVsKingAndSingleKnight" (and (set Var "DrawCondition" 5) (note "Draw by insufficient force king and knight vs king")))                 
        (if "KingsAndBishopsSameColor" (and (set Var "DrawCondition" 6) (note "Draw by insufficient force kings and bishops on same-colored squares")))                      
        (if (= (counter) 99) (and (set Var "DrawCondition" 7) (note "Draw by fifty-move rule")))
        "CountTries"
        (set Var "EquipmentMode" 0)
        (forget Value "IllegalMoves" All)
        (forget Value "CheckSites" All)
        (forget Value "VacatedSite" All)
    })
)

(define "SetEnPassant"
    (set Var "EnPassantSite" (ahead (last To) Backward))
    (set Pending (ahead (last To) Backward))
)

(define "CountEnPassantTries"
    (if (= (what at: (ahead (last To) Rightward)) (next))
        (addScore Next 1)
    )
    (if (= (what at: (ahead (last To) Leftward)) (next))
        (addScore Next 1)
    )
)

(define "PerformLegalMove"
    (or {
        (if (or ("IsMovingPiece" "Pawn") (is Enemy (who at:(last To)))) (set Counter))
        (if (and ("IsMovingPiece" "Pawn") ("InitialPawnMove"))
            (move
                (from (last From))
                (to (last To))
                (then (and {
                    "SetEnPassant"
                    "CommonPostMoveActions"
                    "CountEnPassantTries"
                }))
            )
        )
        (if (and ("IsMovingPiece" "Pawn") ("PawnStep"))
            (move
                (from (last From))
                (to (last To))
                (then
                    (and
                        (if (is In (last To) (sites Mover "Promotion"))
                            (moveAgain)
                        )
                        "CommonPostMoveActions"
                    )
                )
            )
        )
        (if (and ("IsMovingPiece" "Pawn") (or (is Enemy (who at:(last To))) (= (last To) (var "EnPassantSite"))))
            (and
                (if (not (is Enemy (who at:(last To))))
                    (and (set Var "CapturedPiece" (what at:(last From))) (remember Value "VacatedSite" (ahead (last To) Backward) unique:True))
                    
                    (set Var "CapturedPiece" (what at:(last To)))
                )
                (move
                    (from (last From))
                    (to (last To))
                    (then
                        (and {
                            ("NoteCapture" (last To) (var "CapturedPiece"))
                            (if (is In (last To) (sites Mover "Promotion"))
                                (moveAgain)
                            )
                            "CommonPostMoveActions"
                        })
                    )
                )
            )
        )
        (if (!= (var "EnPassantSite") -1) (set Var "EnPassantSite" -1))
        (if (and
                (or { ("MovingTheKing") ("IsMovingPiece" "Knight") ("IsMovingPiece" "Queen") ("IsMovingPiece" "Rook") ("IsMovingPiece" "Bishop")})
                (is Enemy (who at:(last To)))
            )
            (and
                (set Var "CapturedPiece" (what at:(last To)))
                (move
                    (from (last From))
                    (to (last To))
                    (then
                        (and {
                            ("NoteCapture" (last To) (var "CapturedPiece"))
                            "CommonPostMoveActions"
                            ("PieceHasMoved" (last To))
                        })
                    )
                )
            )
        )
        (if (and
                (or { ("MovingTheKing") ("IsMovingPiece" "Knight") ("IsMovingPiece" "Queen") ("IsMovingPiece" "Rook") ("IsMovingPiece" "Bishop")})
                (is Empty (last To))
            )
            (move
                (from (last From))
                (to (last To))
                (then (and "CommonPostMoveActions" ("PieceHasMoved" (last To))))
            )
        )
        (if (and ("MovingTheKing") ("DecideToCastle" E "RookRight"))
            (move
                (from (mapEntry "RookRight" (mover)))
                (to (ahead (mapEntry "RookRight" (mover)) steps: 2 W))
                (then (and "CommonPostMoveActions" ("PieceHasMoved" (ahead (mapEntry "RookRight" (mover)) steps: 2 W))))
            )
        )
        (if (and ("MovingTheKing") ("DecideToCastle" W "RookLeft"))
            (move
                (from (mapEntry "RookLeft" (mover)))
                (to (ahead (mapEntry "RookLeft" (mover)) steps: 3 E))
                (then (and "CommonPostMoveActions" ("PieceHasMoved" (ahead (mapEntry "RookLeft" (mover)) steps: 3 E))))
            )
        )
    })
)

(define "PromotionCondition"
    (and
        (is In (last To) (sites Mover "Promotion"))
        (= (what at: (last To)) (mapEntry "Pawn" Mover))
    )
)

(define "InLocationEnPassant"
    (and
        (is Pending)
        (= (to) (value Pending))
    )
)

(define "EnPassant"
    (move
        Step
        (directions {FR FL})
        (to if: "InLocationEnPassant")
        (then (remove (ahead (last To) Backward)))
    )
)

(define "Attempt"
    (move Select
        (from (from))
        (to
            (sites Direction
                from:(from)
                #1
                stop:(or {
                    (is Friend (who at:(to))) 
                    ("InAttackerSite" (to)) 
                    (and
                        (not ("KingInCheck" (mover) (next)))
                        (is In (+ (* (from) 100) (to)) (values Remembered "IllegalMoves"))
                    )
                })
                stopIncluded:(and {("InAttackerSite" (to)) (!= #2 1) (!= #2 2)})
            )
            if:(and
                (not (is Friend (who at:(to))))
                (or {
                    (= #2 0)
                    (and { (= #2 1) (= 1 (count Steps (from) (to))) (not (is In (+ 100 (to)) (values Remembered "CheckSites")))} ) 
                    (and { (= #2 2) (= 2 (count Steps (from) (to))) (not (is In (+ 100 (to)) (values Remembered "CheckSites")))} )
                    (and {
                        (= #2 3)
                        (= 1 (count Steps (from) (to)))
                        (not (is In (to) (values Remembered "VacatedSite")))
                        (or {
                            (not (is In (from) (sites Start (piece (what at:(from))))))
                            (and {
                                (is In (to) (sites {"A3" "H3" "A6" "H6"})) 
                                (>= (count Turns) 4)
                                (< (count Turns) 6)
                            })
                            (>= (count Turns) 6)
                        })
                        (not (and {
                            (not ("InAttackerSite" (to)))
                            (or 
                                (and (>= (var "AttackerSite") 200) (= (score Mover) 2))
                                (and (>= (var "AttackerSite") 100) (= (score Mover) 1))
                            )
                        }))
                    })
                })
            )
        )
    )
)

(define "KriegspielRook"
    (piece "Rook" Each
        (if (not (= (var "EquipmentMode") 1))
            ("Attempt" Orthogonal 0)

            (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))
        )
    )
)

(define "KriegspielBishop"
    (piece "Bishop" Each
        (if (not (= (var "EquipmentMode") 1))
            ("Attempt" Diagonal 0)

            (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))
        )
    )
)

(define "KriegspielQueen"
    (piece "Queen" Each
        (if (not (= (var "EquipmentMode") 1))
            ("Attempt" (union Orthogonal Diagonal) 0)

            (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))
        )
    )
)

(define "KriegspielPawn"
    (piece "Pawn" Each
        (if (not (= (var "EquipmentMode") 1))
            (or {
                ("Attempt" Forward 1)
                (if (is In (from) (sites Start (piece (what at:(from))))) ("Attempt" Forward 2))
                (if (> (score Mover) 0) ("Attempt" (directions {FR FL}) 3))
            })

            (or {
                "StepForwardToEmpty"
                (if (is In (from) (sites Start (piece (what at:(from))))) "DoubleStepForwardToEmpty")
                ("StepToEnemy" (directions {FR FL}))
                "EnPassant"
            })
        )
    )
)

(define "KriegspielKing"
    (piece "King" Each
        (or
            (move Step All (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))
            (if (and (= (from) (where "King" Mover)) (not (= (var "EquipmentMode") 1)))
                (or
                    (move (from) (to (ahead (from) steps:2 W) 
                        if:(and {
                            ("HasNeverMoved" "King")
                            ("HasNeverMoved" "RookLeft")
                            (not (is Friend (who at:(ahead (from) steps:1 W))))
                            (not (is Friend (who at:(ahead (from) steps:2 W))))
                            (not (is Friend (who at:(ahead (from) steps:3 W))))
                        })
                    ))
                    (move (from) (to (ahead (from) steps:2 E) 
                        if:(and {
                            ("HasNeverMoved" "King")
                            ("HasNeverMoved" "RookRight")
                            (not (is Friend (who at:(ahead (from) steps:1 E))))
                            (not (is Friend (who at:(ahead (from) steps:2 E))))
                        })
                    ))
                )
            )
        )
    )
)

(define "CanMove"
    (if (= (from) (last From))
        (if (not (is In (+ (* (last From) 100) (last To)) (values Remembered "IllegalMoves")))
            (or {
                (= (last To) (where "King" Mover))
                (= 0 (size Array (values Remembered "CheckSites")))
                (is In (last To) (values Remembered "CheckSites")) 
                (is In (+ 100 (last To)) (values Remembered "CheckSites"))
            })
        )
    )
)

(game "Kriegspiel (Chess)"
    (players {(player N) (player S)})
    (equipment {
        (board (square 8))
        ("KriegspielPawn")
        ("KriegspielRook")
        ("KriegspielKing")
        ("KriegspielBishop")
        ("ChessKnight" "Knight")
        ("KriegspielQueen")
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "Queen" {(pair 1 11) (pair 2 12)})
        (map "Rook" {(pair 1 3) (pair 2 4)})
        (map "Bishop" {(pair 1 7) (pair 2 8)})
        (map "Knight" {(pair 1 9) (pair 2 10)})
        (map "Pawn" {(pair 1 1) (pair 2 2)})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    })
    (rules
        (start {
            (place "Pawn1" (sites Row 1))
            (place "Rook1" {"A1" "H1"} state:1)
            (place "Knight1" {"B1" "G1"})
            (place "Bishop1" {"C1" "F1"})
            (place "Queen1" coord:"D1")
            (place "King1" coord:"E1" state:1)
            (place "Pawn2" (sites Row 6))
            (place "Rook2" {"A8" "H8"} state:1)
            (place "Knight2" {"B8" "G8"})
            (place "Bishop2" {"C8" "F8"})
            (place "Queen2" coord:"D8")
            (place "King2" coord:"E8" state:1)
            (set Hidden (sites Occupied by: Mover) to:Next)
            (set Hidden (sites Occupied by: Next) to:Mover)
        })
        (play
            (if (is Proposed "End")
                (or 
                    (move Vote "End"
                        (then (if (= (mover) 1) 
                            (note "Player 1 accepted to end the game")

                            (note "Player 2 accepted to end the game")
                        ))
                    ) 
                    (move Vote "No" (then (do (move Pass))))
                )
                    
                
                (if "PromotionCondition"
                    (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover
                        (then "CommonPostMoveActions")
                    )

                    (or
                        (move Select
                            (from (sites Occupied by:Mover))
                            (to (sites To (do (forEach Piece) ifAfterwards: "CanMove")))
                            (then (if "LegalMove"
                                (and {
                                    (if (!= (var "AttackerSite") -1) (set Var "AttackerSite" -1))
                                    (set Var "EquipmentMode" 1)
                                    "PerformLegalMove"
                                })

                                (and {
                                    (remember Value "IllegalMoves" (+ (* (last From) 100) (last To)) unique:True)
                                    (set Counter (- (counter) 1))
                                    (note "Illegal move")
                                    (moveAgain)
                                })
                            ))
                        )
                        (if (= (var "ProposedEnd") -2)
                            (move Propose "End" 
                                (then (and
                                    (move Vote "End" (then (set Var "ProposedEnd" (+ (count Moves) 1)))) 
                                    (if (= (mover) 1) 
                                        (note "Player 1 proposes to end the game") 
                                        
                                        (note "Player 2 proposes to end the game")
                                    )
                                ))
                            )
                        )
                    )
                )
            )
        )
        (end {
            (if (= (var "NextLost") 1) (result Mover Win))
            (if (or (>= (var "DrawCondition") 1) (is Decided "End")) (result Mover Draw))
        })
    )
)
// 
    DISABLED: if (= (var "ProposedEnd") (count Moves)) ...
    Problem 1: AI agents spam "Propose End" moves.
    Problem 2: (is Repeat) seems to count proposal moves, triggering false draw-by-repetition.
    Current workaround: always disabled, condition (ProposedEnd = -2) never true.
    Note: When enabled, proposals are limited to one per turn and must precede any move attempt.
//

(metadata
    (info
        {
        (description "
            Kriegspiel is a chess variant in which each player can see their own pieces, but not those of their opponent. For this reason, it is necessary to have a third person (or computer) act as an umpire, with full information about the progress of the game. Players attempt to move on their turns, and the umpire declares their attempts 'legal' or 'illegal'. If the move is illegal, the player tries again; if it is legal, that move stands. Each player is given information about checks and captures. Since the position of the opponent's pieces is unknown, Kriegspiel is a game of imperfect information.
            This implementation pre-filters moves that fail feasibility checks, eliminating 'Hell no' (or 'Impossible' or 'Nonsense') announcements (when the attempted move is always illegal regardless of the opponent's position). All filtering is based exclusively on information legitimately available to the player (game rules, own pieces, and information derivable from umpire announcements and move history), organized into the following domains:
            A - Memory
                - A1: Rejected moves are excluded for the remainder of the turn.
                - A2: Sliding trajectories stop at previously rejected destinations (except when the side is in check).
            B - Geometry
                - B1: Pieces follow canonical movement patterns.
                - B2: Sliding trajectories stop at friendly pieces.
                - B3: Castling requires unmoved King/Rook and intermediate squares not occupied by friendly pieces.
                - B4: Early-game (pawns on starting rank)
                    - B4.1: Turns 1-2: no pawn captures (enemies cannot reach rows 3/6).
                    - B4.2: Turns 3-4: pawn captures limited to A3, H3, A6, H6 (squares reachable by a bishop).
            C - Umpire inference
                - C1: Pawn captures are enabled only when `Tries` > 0.
                - C2: Sliding pieces stop at `AttackerSite`.
                - C3: Pawns cannot advance onto `AttackerSite`.
                - C4: If `Tries` equals the number of pawns that can reach `AttackerSite`, other captures are excluded.
                - C5: Pawn captures onto `VacatedSite` are excluded.
                - C6: Under check, only moves to `CheckSites` or King moves are allowed; castling is excluded.
                - C7: Pawns cannot advance onto terminal `CheckSites`.
            Glossary
            `Tries`: Number of legal pawn captures available this turn (announced by the umpire). Includes en passant.
            `AttackerSite`: Square where an enemy captured a piece and now occupies; encoded values: [site], [site+100] (one pawn can recapture), [site+200] (two pawns can).
            `CheckSites`: Squares along a check line where interposition is possible; encoded as [site] (intermediate) and [site+100] (terminal - farthest visible square).
            `VacatedSite`: Square emptied by an en passant capture (the captured pawn's original location).
            `IllegalMoves`: Memory of moves rejected during the turn (encoded as [from*100+to]).
            Note: The filtering heuristics implemented here are not exhaustive. Additional implausible-move filters may be derived from game state and umpire announcements.
        ")
        (aliases {"Blind Chess" "Wild 16"})
        (rules "
            The game follows standard chess rules and is played with three boards, one for each player; the third is for the umpire (and spectators). Each opponent knows the exact position of just their own pieces, and does not know where the opponent's pieces are (but can keep track of how many there are). Only the umpire knows the position of the game. The game proceeds in the following way:
            The umpire makes the following announcements where appropriate:
            -`Player 1 (White)'s [or Player 2 (Black)'s] turn`.
            -`Pawn [or Piece] at (square) captured`, when a pawn or a piece is captured. The square of the victim is announced. (En passant captures are specifically announced as such, e.g. `Pawn at A4 captured en passant`)
            -`Illegal move` when the attempted move is illegal, given the opponent`s position (e.g. moving the king into check; moving a queen, rook, bishop, or pawn through squares occupied by the opponent`s pieces; advancing a pawn into a square occupied by the opponent's pieces; castling through check or across occupied squares; moving a piece under an absolute pin).
            -`Rank check`.
            -`File check`.
            -`Long-diagonal check` (the longer of the two diagonals, from the king's point of view).
            -`Short-diagonal check` (e.g. for a king on E1, the short diagonal is E1 to H4).
            -`Knight check`.
            -`(number) tries` (the number of legal pawn-capture moves available in the turn; captures are not obligatory. Displayed in each player's score).
            -`Checkmate`, `stalemate`
            -`draw by repetition` when the same position occurs for the third time, the umpire automatically declares the game a draw and the game ends immediately (no claim by the players is required).
            -`draw by insufficient force kings only [or king and bishop vs king; king and knight vs king; kings and bishops on same-colored squares]`.
            -`50-move draw` (the illegal moves do not count towards the fifty moves).
            (DISABLED -`Player 1 (White)'s [or Player 2 (Black)'s] proposes [or accepted] to end the game` when a player propose/accept to end the game in draw. Proposals are limited to one per player per turn to avoid infinite loops or spam.)
            Pawn promotions are not announced. The precise location of the checking piece is not announced (although it may be deduced).
            Illegal move attempts are not announced to the opponent. As soon as the umpire rejects one it disappears from the moverâ€™s options for the rest of that turn, eliminating wasted retries.
        ")
        (id "4185") 
        (source "<a href=\"https://en.wikipedia.org/wiki/Kriegspiel_(chess)\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.14")
        (classification "board/war/replacement/checkmate/chess")
        (author "Henry Michael Temple")
        (credit "Nikola Novarlic & Fabio Chiarini")
        (date "1899")
        }
    )
    (graphics {
        (show Score Always " tries")
        (piece Scale "Pawn" 0.825)
        (piece Families {"Defined" "Microsoft" "Pragmata" "Symbola"})
        (board Style Chess)
    })
)

